<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mezzanine::xml Manual</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script> 
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>MezzanineEngine&#160;<span id="projectnumber"></span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Mezzanine::xml Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This will describe how to use the XML components of the <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> </p>
<h1><a class="anchor" id="XMLTOC"></a>
Table Of Contents</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLOverview">Overview</a><ul>
<li><a class="el" href="XMLManual.html#XMLIntroduction">Introduction</a></li>
<li><a class="el" href="XMLManual.html#XMLFeedBack">FeedBack</a></li>
<li><a class="el" href="XMLManual.html#XMLAcknowledgments">Acknowledgments</a></li>
<li><a class="el" href="XMLManual.html#XMLLicense">License</a></li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLDOM">Document Object Model</a><ul>
<li><a class="el" href="XMLManual.html#XMLTreeStructure">Tree structure</a></li>
<li><a class="el" href="XMLManual.html#XMLInterface">C++ interface</a></li>
<li><a class="el" href="XMLManual.html#XMLThreadSafety">Thread-safety guarantees</a></li>
<li><a class="el" href="XMLManual.html#XMLExceptionSafety">Exception guarantees</a></li>
<li><a class="el" href="XMLManual.html#XMLMemory">Memory management</a><ul>
<li><a class="el" href="XMLManual.html#XMLCustomAlloc">Custom memory allocation/deallocation functions</a></li>
<li><a class="el" href="XMLManual.html#XMLMemoryInternals">Document memory management internals</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLLoading">Loading Documents</a><ul>
<li><a class="el" href="XMLManual.html#XMLLoadingFiles">Loading Document from a File</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingFromMemory">Loading document from memory</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingStreams">Loading document from C++ IOstreams</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingErrors">Handling Parsing Errors</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingParsingOptions">Parsing Options</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingEncodings">Encodings</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingStandards">Conformance to W3C Specification</a></li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLAccessing">Accessing Document Data</a><ul>
<li><a class="el" href="XMLManual.html#XMLAccessingBasics">Basic traversal functions</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingNodeData">Getting Node Data</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingAttributeData">Getting attribute data</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingContentBased">Content Based Traversal Functions</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingIterators">Traversing Node/Attribute Lists via Iterators</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingWalker">Recursive traversal with Mezzanine::XML::TreeWalker</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingPredicates">Searching for Nodes/Attributes with Predicates</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingMisc">Miscellaneous functions</a></li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLModifying">Modifiying Documents</a><ul>
<li><a class="el" href="XMLManual.html#XMLModifyingNodeData">Setting Node Data</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingAttributeData">Setting Attribute Data</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingAdding">Adding Nodes/Attributes</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingRemoving">Removing Nodes/Attributes</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingCloning">Cloning Nodes/Attributes</a></li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLSaving">Saving Documents</a><ul>
<li><a class="el" href="XMLManual.html#XMLSavingFile">Saving Documents to Files</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingStreams">Saving Documents to C++ IOstreams</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingWriter">Saving Document via Writer Interface</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingSubtree">Saving a Single Subtree</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingOptions">Output Options</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingEncodings">Encodings</a></li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLXPath">XPath</a><ul>
<li><a class="el" href="XMLManual.html#XMLXPathTypes">XPath Types</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathSelecting">Selecting Nodes via XPath Expression</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathQuery">Using Query Objects</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathVariables">Using Variables</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathError">Error Handling</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathStandards">Conformance to W3C Specification</a></li>
</ul>
</li>
</ul>
<p><br />
 <br />
</p>
<h1><a class="anchor" id="XMLOverview"></a>
Overview</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLIntroduction">Introduction</a></li>
<li><a class="el" href="XMLManual.html#XMLFeedBack">FeedBack</a></li>
<li><a class="el" href="XMLManual.html#XMLAcknowledgments">Acknowledgments</a></li>
<li><a class="el" href="XMLManual.html#XMLLicense">License</a></li>
</ul>
<h2><a class="anchor" id="XMLIntroduction"></a>
Introduction</h2>
<p>Mezzanine::xml is a light-weight C++ XML processing library. It consists of a DOM-like interface with rich traversal/modification capabilities, an extremely fast XML parser which constructs the DOM tree from an XML file/buffer, and an <a class="el" href="classMezzanine_1_1XML_1_1XPathQuery.html">XPath 1.0 implementation</a> for complex data-driven tree queries. Unicode is fully support via UF8 in 8bit characters and for conversions between different Unicode encodings (which happen automatically during parsing/saving). <br />
 <br />
 Mezzanine::xml enables very fast, convenient and memory-efficient XML document processing. However, since Mezzanine::xml has a DOM parser, it can't process XML documents that do not fit in memory; also the parser is a non-validating one, so if you need DTD or XML Schema validation, the XML parser is not for you. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLFeedBack"></a>
FeedBack</h2>
<p>If you believe you've found a bug in Mezzanine::xml (bugs include compilation problems (errors/warnings), crashes, performance degradation and incorrect behavior), please contact Blacktopp Studios Inc ( <a href="http://www.blacktoppstudios.com/">http://www.blacktoppstudios.com/</a> ) . We check the the Forums ( <a href="http://www.blacktoppstudios.com/?page_id=753">http://www.blacktoppstudios.com/?page_id=753</a> ) and items sent by our contact form ( <a href="http://www.blacktoppstudios.com/?page_id=33">http://www.blacktoppstudios.com/?page_id=33</a> ) regularly. Be sure to include the relevant information so that the bug can be reproduced: the version of Mezzanine::xml, compiler version and target architecture, the code that uses Mezzanine::xml and exhibits the bug, etc. <br />
 <br />
 Feature requests can be reported the same way as bugs, so if you're missing some functionality in Mezzanine::xml or if the API is rough in some places and you can suggest an improvement, please let us know. However, please note that there are many factors when considering API changes (compatibility with previous versions, API redundancy, etc.). <br />
 <br />
 If you have a contribution to Mezzanine::xml, such as build script for some build system/IDE, or a well-designed set of helper functions, or a binding to some language other than C++, please let us know. You can include the relevant patches as issue attachments. We will have to communicate on the Licensing terms of your contribution though. <br />
 <br />
 If the provided methods of contact have an issue or not possible due to privacy or other concerns, you can contact the Mezzanine::xml author ( <a href="#" onclick="location.href='mai'+'lto:'+'top'+'pi'+'j@b'+'la'+'ckt'+'op'+'pst'+'ud'+'ios'+'.c'+'om'; return false;">toppi<span style="display: none;">.nosp@m.</span>j@bl<span style="display: none;">.nosp@m.</span>ackto<span style="display: none;">.nosp@m.</span>ppst<span style="display: none;">.nosp@m.</span>udios<span style="display: none;">.nosp@m.</span>.com</a> ) or pugixml author ( <a href="#" onclick="location.href='mai'+'lto:'+'ars'+'en'+'y.k'+'ap'+'oul'+'ki'+'ne@'+'gm'+'ail'+'.c'+'om'; return false;">arsen<span style="display: none;">.nosp@m.</span>y.ka<span style="display: none;">.nosp@m.</span>poulk<span style="display: none;">.nosp@m.</span>ine@<span style="display: none;">.nosp@m.</span>gmail<span style="display: none;">.nosp@m.</span>.com</a> ) by e-mail directly. If you have an issue that pertains to pugixml and not Mezzanine::xml you can visit the pugixml issue submission form ( <a href="http://code.google.com/p/pugixml/issues/entry">http://code.google.com/p/pugixml/issues/entry</a> ) of the pugixml feature request form ( <a href="http://code.google.com/p/pugixml/issues/entry?template=Feature%20request">http://code.google.com/p/pugixml/issues/entry?template=Feature%20request</a> ). <br />
 <br />
</p>
<h2><a class="anchor" id="XMLAcknowledgments"></a>
Acknowledgments</h2>
<p>Mezzanine::xml and pugixml could not be developed without the help from many people; some of them are listed in this section. If you've played a part in Mezzanine::xml or pugixml development and you can not find yourself on this list, I'm truly sorry; please send me an e-mail ( <a href="#" onclick="location.href='mai'+'lto:'+'top'+'pi'+'j@b'+'la'+'ckt'+'op'+'pst'+'ud'+'ios'+'.c'+'om'; return false;">toppi<span style="display: none;">.nosp@m.</span>j@bl<span style="display: none;">.nosp@m.</span>ackto<span style="display: none;">.nosp@m.</span>ppst<span style="display: none;">.nosp@m.</span>udios<span style="display: none;">.nosp@m.</span>.com</a> ) so I can fix this. <br />
 <br />
 Thanks to <b>Arseny</b> <b>Kapoulkine</b> for pugixml parser, which was used as a basis for Mezzanine::xml. <br />
 <br />
 Thanks to <b>Kristen</b> <b>Wegner</b> for pugxml parser, which was used as a basis for pugixml. <br />
 <br />
 Thanks to <b>Neville</b> <b>Franks</b> for contributions to pugxml parser. <br />
 <br />
 Thanks to <b>Artyom</b> <b>Palvelev</b> for suggesting a lazy gap contraction approach. <br />
 <br />
 Thanks to <b>Vyacheslav</b> <b>Egorov</b> for documentation proofreading. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLLicense"></a>
License</h2>
<p>With written permission as per <a class="el" href="OriginalpugixmlLicense.html">The original pugixml license</a> we he sublicensed Mezzanine::xml under the <a class="el" href="GPLLicense.html">GPL Version 3</a>. In short This allows you to use Mezzanine::xml however you like with a few restrictions. If you change Mezzanine::xml you need to make the changes publically available. If you make software using Mezzanine::xml you need to make the source code publicly available. You may not use and Digital Rights Management (DRM) software to limit how others use the combined work you make. You can sell resulting works, but not through a digital distribution store that uses DRM.</p>
<p><br />
 <br />
</p>
<h1><a class="anchor" id="XMLDOM"></a>
Document Object Model</h1>
<p>Mezzanine::xml stores XML data in DOM-like way: the entire XML document (both document structure and element data) is stored in memory as a tree. The tree can be loaded from a character stream (file, string, C++ I/O stream), then traversed with the special API or XPath expressions. The whole tree is mutable: both node structure and node/attribute data can be changed at any time. Finally, the result of document transformations can be saved to a character stream (file, C++ I/O stream or custom transport).</p><ul>
<li><a class="el" href="XMLManual.html#XMLTreeStructure">Tree structure</a></li>
<li><a class="el" href="XMLManual.html#XMLInterface">C++ interface</a></li>
<li><a class="el" href="XMLManual.html#XMLThreadSafety">Thread-safety guarantees</a></li>
<li><a class="el" href="XMLManual.html#XMLExceptionSafety">Exception guarantees</a></li>
<li><a class="el" href="XMLManual.html#XMLMemory">Memory management</a><ul>
<li><a class="el" href="XMLManual.html#XMLCustomAlloc">Custom memory allocation/deallocation functions</a></li>
<li><a class="el" href="XMLManual.html#XMLMemoryInternals">Document memory management internals</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="XMLTreeStructure"></a>
Tree structure</h2>
<p>The XML document is represented with a tree data structure. The root of the tree is the document itself, which corresponds to C++ type <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a>. A Document has one or more child nodes, which correspond to C++ type <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>. Nodes have different types; depending on a type, a node can have a collection of child nodes, a collection of attributes, which correspond to C++ type <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a>, and some additional data (i.e. Name). <br />
 <br />
 The tree nodes can be of one of the following types (which together form the enumeration <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a" title="The types of nodes that could be in the XML Tree. ">Mezzanine::XML::NodeType</a>):</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocument Document node</a> - This is the root of the tree, which consists of several child nodes. This node corresponds to <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> class; note that <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> is a sub-class of <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>, so the entire node interface is also available. However, document nodes are special in several ways, which are covered below. There can be only one document node in the tree; document node does not have any XML representation. <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeElement Element/tag node</a> - This is the most common type of node, which represents XML elements. Element nodes have a name, a collection of attributes and a collection of child nodes (both of which may be empty). The attribute is a simple name/value pair. The example XML representation of element nodes is as follows: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;node attr=&quot;value&quot;&gt;&lt;child/&gt;&lt;/node&gt;</div>
</div><!-- fragment --> There are two element nodes here: one has name "node", single attribute "attr" and the single child "child" which has the name "child" and does not have any attributes or child nodes. <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodePcdata Plain character data node</a> - Represent plain text in XML. PCDATA nodes have a value, but do not have a name or children/attributes. Note that plain character data is not a part of the element node but instead has its own node; for example, an element node can have several child PCDATA nodes. The example XML representation of text nodes is as follows: <div class="fragment"><div class="line">&lt;node&gt; text1 &lt;child/&gt; text2 &lt;/node&gt;</div>
</div><!-- fragment --> Here "node" element has three children, two of which are PCDATA nodes with values "text1" and "text2". <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeCdata Character data nodes</a> - These represent text in XML that is quoted in a special way. CDATA nodes do not differ from PCDATA nodes except in XML representation - the above text example looks like this with CDATA: <div class="fragment"><div class="line">&lt;node&gt; &lt;![CDATA[[text1]]&gt; &lt;child/&gt; &lt;![CDATA[[text2]]&gt; &lt;/node&gt;</div>
</div><!-- fragment --> CDATA nodes make it easy to include non-escaped &lt;, &amp; and &gt; characters in plain text. CDATA value can not contain the character sequence ]]&gt;, since it is used to determine the end of node contents. <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeComment Comment nodes</a> - represent comments in XML. Comment nodes have a value, but do not have a name or children/attributes. The example XML representation of a comment node is as follows: <div class="fragment"><div class="line">&lt;!-- comment text --&gt;</div>
</div><!-- fragment --> Here the comment node has value "comment text". By default comment nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespaceMezzanine_1_1XML.html#aa47eb6ac501513239cda4ff7b23f6786" title="This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default...">Mezzanine::XML::ParseComments</a> flag. <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodePi Processing instruction node</a> - Represent Processing Instructions (PI) in XML. PI nodes have a name and an optional value, but do not have children/attributes. The example XML representation of a PI node is as follows: <div class="fragment"><div class="line">&lt;?name value?&gt;</div>
</div><!-- fragment --> Here the name (also called PI target) is "name", and the value is "value". By default PI nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespaceMezzanine_1_1XML.html#a10dfe21f7a8edcd95c34de367b723a1e" title="This flag determines if processing instructions (NodePi) are added to the DOM tree. This flag is off by default. ">Mezzanine::XML::ParsePi</a> flag. <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDeclaration Declaration node</a> - Represents document declarations in XML. Declaration nodes have a name ("xml") and an optional collection of attributes, but do not have value or children. There can be only one declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a declaration node is as follows: <div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;</div>
</div><!-- fragment --> Here the node has name "xml" and a single attribute with name "version" and value "1.0". By default declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespaceMezzanine_1_1XML.html#a8f36bcf2332a3393c6bb437f080e7468" title="This flag determines if document declaration (NodeDeclaration) is added to the DOM tree...">Mezzanine::XML::ParseDeclaration</a> flag. Also, by default a dummy declaration is output when XML document is saved unless there is already a declaration in the document; you can disable this with <a class="el" href="namespaceMezzanine_1_1XML.html#a965e10fd6db7e52461671ce5a05da1e6" title="Omit default XML declaration even if there is no declaration in the document. This flag is off by def...">Mezzanine::XML::FormatNoDeclaration</a> flag. <br />
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocType Document type declaration node</a> - Represents document type declarations in XML. Document type declaration nodes have a value, which corresponds to the entire document type contents; no additional nodes are created for inner elements like &lt;!ENTITY&gt;. There can be only one document type declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a document type declaration node is as follows: <div class="fragment"><div class="line">&lt;!DOCTYPE greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]&gt;</div>
</div><!-- fragment --> Here the node has value "greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]". By default document type declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespaceMezzanine_1_1XML.html#a9a5951b276f36d8260f299b0dad23dfd" title="This flag determines if document type declaration (NodeDoctype) is added to the DOM tree...">Mezzanine::XML::ParseDocType</a> flag. <br />
 <br />
 <br />
 Finally, here is a complete example of XML document and the corresponding tree representation: <div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;</div>
<div class="line">&lt;mesh name=<span class="stringliteral">&quot;mesh_root&quot;</span>&gt;</div>
<div class="line">    &lt;!-- here is a mesh node --&gt;</div>
<div class="line">    some text</div>
<div class="line">    &lt;![CDATA[someothertext]]&gt;</div>
<div class="line">    some more text</div>
<div class="line">    &lt;node attr1=<span class="stringliteral">&quot;value1&quot;</span> attr2=<span class="stringliteral">&quot;value2&quot;</span> /&gt;</div>
<div class="line">    &lt;node attr1=<span class="stringliteral">&quot;value2&quot;</span>&gt;</div>
<div class="line">        &lt;innernode/&gt;</div>
<div class="line">    &lt;/node&gt;</div>
<div class="line">&lt;/mesh&gt;</div>
<div class="line">&lt;?include somedata?&gt;</div>
</div><!-- fragment --> <div class="image">
<img src="SampleTree.jpg" alt="SampleTree.jpg"/>
<div class="caption">
Complete Tree Representation of the Sample</div></div>
  </li>
</ul>
<h2><a class="anchor" id="XMLInterface"></a>
C++ interface</h2>
<p>Despite the fact that there are several node types, there are only three C++ classes representing the tree (<a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a>, <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>, <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a>); some operations on <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> are only valid for certain node types. The classes are described below. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> is the owner of the entire document structure; it is a non-copyable class. The interface of <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> consists of loading functions ( see <a class="el" href="XMLManual.html#XMLLoading">Loading Documents</a> ), saving functions ( see <a class="el" href="XMLManual.html#XMLSaving">Saving Documents</a> ) and the entire interface of <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>, which allows for document inspection and/or modification. Note that while <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> is a sub-class of <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>, <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> is not a polymorphic type; the inheritance is present only to simplify usage. Alternatively you can use the <a class="el" href="classMezzanine_1_1XML_1_1Document.html#aac1611207ee9ef11a80bc1796020cf4d" title="Get document element. ">Mezzanine::XML::Document::DocumentElement</a> function to get the element node that's the immediate child of the document. <br />
 <br />
 Default constructor of <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> initializes the document to the tree with only a root node ( <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> node). You can then populate it with data using either tree modification functions or loading functions; all loading functions destroy the previous tree with all occupied memory, which puts existing node/attribute handles for this document to invalid state. If you want to destroy the previous tree, you can use the <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a8dd37aaa59b59a89c34f927e8aaa76ed" title="Removes all nodes, leaving the empty document. ">Mezzanine::XML::Document::Reset</a> function; it destroys the tree and replaces it with either an empty one or a copy of the specified document. Destructor of <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> also destroys the tree, thus the lifetime of the document object should exceed the lifetimes of any node/attribute handles that point to the tree. </p><dl class="section warning"><dt>Warning</dt><dd>While technically node/attribute handles can be alive when the tree they're referring to is destroyed, calling any member function for these handles results in undefined behavior. Thus it is recommended to make sure that the document is destroyed only after all references to its nodes/attributes are destroyed.</dd></dl>
<p><a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> is the handle to a document node; it can point to any node in the document, including the document node itself. There is a common interface for nodes of all types; the actual node type can be queried via the <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a0337fae875c80702cc9a1540e84b07a8" title="Identify what kind of Node this is. ">Mezzanine::XML::Node::Type()</a> method. Note that <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> is only a handle to the actual node, not the node itself - you can have several Mezzanine::XML::node handles pointing to the same underlying object. Destroying <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> handle does not destroy the node and does not remove it from the tree. The size of <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> is equal to that of a pointer, so it is nothing more than a lightweight wrapper around a pointer; you can safely pass or return Mezzanine::xml:Node objects by value without additional overhead. <br />
 <br />
 There is a special value of <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> type, known as null node or empty node (such nodes have type NodeNull). It does not correspond to any node in any document, and thus resembles null pointer. However, all operations are defined on empty nodes; generally the operations don't do anything and return empty nodes/attributes or empty strings as their result (see documentation for specific functions for more detailed information). This is useful for chaining calls; i.e. you can get the grandparent of a node like so: node.GetParent().GetParent(); if a node is a null node or it does not have a parent, the first Node::GetParent() call returns null node; the second GetParent() call then also returns null node, which can make error handling easier. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> is a handle to an XML attribute; it has the same semantics as <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>, i.e. there can be several <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> handles pointing to the same underlying object and there is a special null attribute value, which propagates to function results. <br />
 <br />
 Both <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> and <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> have the default constructor which initializes them to null objects. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> and <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> try to behave like pointers, that is, they can be compared with other objects of the same type, making it possible to use them as keys in associative containers. All handles to the same underlying object are equal, and any two handles to different underlying objects are not equal. Null handles only compare as equal to themselves. The result of relational comparison can not be reliably determined from the order of nodes in file or in any other way. Do not use relational comparison operators except for search optimization (i.e. associative container keys). <br />
 <br />
 If you want to use <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> or <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> objects as keys in hash-based associative containers, you can use the <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a7a5321c66997f7aee85b73257856638c" title="Get hash Value (unique for handles to the same object) ">Mezzanine::XML::Node::HashValue</a> or <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html#a13a78a7cf64c91e879f6ee910fa1c712" title="Get a unique identifying value for the Attribute this represents. ">Mezzanine::XML::Attribute::HashValue</a> member functions. They return the hash values that are guaranteed to be the same for all handles to the same underlying object. The hash value for null handles is 0. <br />
 <br />
 Finally handles can be implicitly cast to boolean-like objects, so that you can test if the node/attribute is empty with the following code: if (node) { ... } or if (!node) { ... } else { ... }. Alternatively you can check if a given Node/Attribute handle is null by calling the <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html#a9f3ac1beb83562f6b2c155772b87dc05" title="Is this storing anything at all? ">Mezzanine::XML::Attribute::Empty</a> or the <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a8c770f21644c937e1e5ca1fd9966651b" title="Is this storing anything at all? ">Mezzanine::XML::Node::Empty</a> Methods. <br />
 <br />
 Nodes and attributes do not exist without a document tree, so you can't create them without adding them to some document. Once underlying node/attribute objects are destroyed, the handles to those objects become invalid. While this means that destruction of the entire tree invalidates all node/attribute handles, it also means that destroying a subtree ( by calling <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a7fb291fef7d56df2d6e0e0fc9a28e78b" title="Remove specified child element. ">Mezzanine::XML::Node::RemoveChild</a> ) or removing an attribute invalidates the corresponding handles. There is no way to check handle validity; you have to ensure correctness through external mechanisms. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLThreadSafety"></a>
Thread-safety guarantees</h2>
<p>Almost all functions in Mezzanine::xml have the following thread-safety guarantees:</p><ul>
<li>It is safe to call free (non-member) functions from multiple threads</li>
<li>It is safe to perform concurrent read-only accesses to the same tree (all constant member functions do not modify the tree)</li>
<li>It is safe to perform concurrent read/write accesses, if there is only one read or write access to the single tree at a time</li>
</ul>
<p>Concurrent modification and traversing of a single tree requires synchronization, for example via reader-writer lock. Modification includes altering document structure and altering individual node/attribute data, i.e. changing names/values. <br />
 <br />
 The only exception is Mezzanine::XML::SetMemory_management_functions; it modifies global variables and as such is not thread-safe. Its usage policy has more restrictions, see <a class="el" href="XMLManual.html#XMLCustomAlloc">Custom memory allocation/deallocation functions</a> . <br />
 <br />
</p>
<h2><a class="anchor" id="XMLExceptionSafety"></a>
Exception guarantees</h2>
<p>With the exception of XPath, Mezzanine::xml itself does not throw any exceptions. Additionally, most Mezzanine::xml functions have a no-throw exception guarantee. <br />
 <br />
 This is not applicable to functions that operate on STL strings or IOstreams; such functions have either strong guarantee (functions that operate on strings) or basic guarantee (functions that operate on streams). Also functions that call user-defined callbacks (i.e. <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a60c011dca7c524ff915d1aa8a048a577" title="Perform sophisticated (or whatever) algorithms on this and all descendant Nodes in the XML tree...">Mezzanine::XML::Node::Traverse</a> or <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a5b6592942502b7cc6b5eb19baef24b85" title="Search for any Node descended from this Node using a function to check each Node individually. ">Mezzanine::XML::Node::FindNode</a>) do not provide any exception guarantees beyond the ones provided by the callback. <br />
 <br />
 XPath functions may throw Mezzanine::XML::XPathException on parsing errors; also, XPath functions may throw std::bad_alloc in low memory conditions. Still, XPath functions provide strong exception guarantee. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLMemory"></a>
Memory management</h2>
<p>Mezzanine::xml requests the memory needed for document storage in big chunks, and allocates document data inside those chunks. This section discusses replacing functions used for chunk allocation and internal memory management implementation. <br />
 <br />
 </p><dl class="section warning"><dt>Warning</dt><dd>The Mezzanine::xml memory system is pending tighter integration with memory management from the rest of the system. The functions and features described here should be considered deprecated and internal to the engine. It is highly likely they will be replaced without warning by a global system to allocate memory in a more efficient way.</dd></dl>
<p><br />
 <br />
</p>
<h3><a class="anchor" id="XMLCustomAlloc"></a>
Custom memory allocation/deallocation functions</h3>
<p>All memory for tree structure, tree data and XPath objects is allocated via globally specified functions, which default to malloc/free. You can set your own allocation functions with Mezzanine::XML::SetMemory_management_functions function. The function interfaces are the same as that of malloc/free: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">void</span>* (*AllocationFunction)(<span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keyword">typedef</span> void (*deAllocationFunction)(<span class="keywordtype">void</span>* ptr);</div>
</div><!-- fragment --><p> You can use the following accessor functions to change or get current memory management functions: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Mezzanine::XML::SetMemory_management_functions(<a class="code" href="namespaceMezzanine_1_1XML.html#a6e33931c05344d3ce479661905a9136c">AllocationFunction</a> allocate, deAllocationFunction deallocate);</div>
<div class="line"><a class="code" href="namespaceMezzanine_1_1XML.html#a6e33931c05344d3ce479661905a9136c">AllocationFunction</a> GetMemoryAllocationFunctionn();</div>
<div class="line">deAllocationFunction <a class="code" href="namespaceMezzanine_1_1XML.html#a29489f570c35337d137e8c5daae27611">GetMemoryDeallocationFunction</a>();</div>
</div><!-- fragment --><p> Allocation function is called with the size (in bytes) as an argument and should return a pointer to a memory block with alignment that is suitable for storage of primitive types (usually a maximum of void* and double types alignment is sufficient) and size that is greater than or equal to the requested one. If the allocation fails, the function has to return null pointer (throwing an exception from allocation function results in undefined behavior). <br />
 <br />
 Deallocation function is called with the pointer that was returned by some call to allocation function; it is never called with a null pointer. If memory management functions are not thread-safe, library thread safety is not guaranteed. <br />
 <br />
 When setting new memory management functions, care must be taken to make sure that there are no live Mezzanine::xml objects. Otherwise when the objects are destroyed, the new deallocation function will be called with the memory obtained by the old allocation function, resulting in undefined behavior. <br />
 <br />
</p>
<h3><a class="anchor" id="XMLMemoryInternals"></a>
Document memory management internals</h3>
<p>Constructing a document object using the default constructor does not result in any allocations; document node is stored inside the <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> object <br />
 <br />
 When the document is loaded from file/buffer, unless an inplace loading function is used ( see <a class="el" href="XMLManual.html#XMLLoadingFromMemory">Loading document from memory</a> ), a complete copy of character stream is made; all names/values of nodes and attributes are allocated in this buffer. This buffer is allocated via a single large allocation and is only freed when document memory is reclaimed (i.e. if the <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">Mezzanine::XML::Document</a> object is destroyed or if another document is loaded in the same object). Also when loading from file or stream, an additional large allocation may be performed if encoding conversion is required; a temporary buffer is allocated, and it is freed before load function returns. <br />
 <br />
 All additional memory, such as memory for document structure (node/attribute objects) and memory for node/attribute names/values is allocated in pages on the order of 32 kilobytes; actual objects are allocated inside the pages using a memory management scheme optimized for fast allocation/deallocation of many small objects. Because of the scheme specifics, the pages are only destroyed if all objects inside them are destroyed; also, generally destroying an object does not mean that subsequent object creation will reuse the same memory. This means that it is possible to devise a usage scheme which will lead to higher memory usage than expected; one example is adding a lot of nodes, and them removing all even numbered ones; not a single page is reclaimed in the process. However this is an example specifically crafted to produce unsatisfying behavior; in all practical usage scenarios the memory consumption is less than that of a general-purpose allocator because allocation meta-data is very small in size. <br />
 <br />
</p>
<h1><a class="anchor" id="XMLLoading"></a>
Loading Documents</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLLoadingFiles">Loading Document from a File</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingFromMemory">Loading document from memory</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingStreams">Loading document from C++ IOstreams</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingErrors">Handling Parsing Errors</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingParsingOptions">Parsing Options</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingEncodings">Encodings</a></li>
<li><a class="el" href="XMLManual.html#XMLLoadingStandards">Conformance to W3C Specification</a></li>
</ul>
<p>Mezzanine::xml provides several functions for loading XML data from various places - files, C++ iostreams, memory buffers. All functions use an extremely fast non-validating parser. This parser is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid XML documents, some validation is not performed for performance reasons. Also some XML transformations (i.e. EOL handling or attribute value normalization) can impact parsing speed and thus can be disabled. However for vast majority of XML documents there is no performance difference between different parsing options. Parsing options also control whether certain XML nodes are parsed; see <a class="el" href="XMLManual.html#XMLLoadingParsingOptions">Parsing Options</a> for more information. <br />
 <br />
 XML data is always converted to internal character format before parsing. Mezzanine::xml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it's a strict subset of UTF-16) and handles all encoding conversions automatically. Unless explicit encoding is specified, loading functions perform automatic encoding detection based on first few characters of XML data, so in almost all cases you do not have to specify document encoding. Encoding conversion is described in more detail in <a class="el" href="XMLManual.html#XMLLoadingEncodings">Encodings</a>. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLLoadingFiles"></a>
Loading Document from a File</h2>
<p>The most common source of XML data is files; Mezzanine::xml provides dedicated functions for loading an XML document from file: </p><div class="fragment"><div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a89365dd7aa1cd2e25ebd72ceae8cad90">Mezzanine::XML::Document::LoadFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options = <a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Mezzanine::XML::Encoding</a> DocumentEncoding = <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>);</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a89365dd7aa1cd2e25ebd72ceae8cad90">Mezzanine::XML::Document::LoadFile</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* path, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options = <a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Mezzanine::XML::Encoding</a> DocumentEncoding = <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>);</div>
</div><!-- fragment --><p> These functions accept the file path as its first argument, and also two optional arguments, which specify parsing options (see Parsing options) and input data encoding ( see <a class="el" href="XMLManual.html#XMLLoadingEncodings">Encodings</a> ). The path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of the target system, it should have the exact case if the target file system is case-sensitive, and is subject to any other restrictions of the underlying filesystem. <br />
 <br />
 File path is passed to the system file opening function as is in case of the first function (which accepts const char* path); the second function either uses a special file opening function if it is provided by the runtime library or converts the path to UTF-8 and uses the system file opening function. <br />
 <br />
 Document::LoadFile destroys the existing document tree and then tries to load the new tree from the specified file. The result of the operation is returned in an <a class="el" href="structMezzanine_1_1XML_1_1ParseResult.html" title="Troubleshooting data intended to help troublshoot XML parsing errors. ">Mezzanine::XML::ParseResult</a> object; this object contains the operation status and the related information (i.e. last successfully parsed position in the input file, if parsing fails). See <a class="el" href="XMLManual.html#XMLLoadingErrors">Handling Parsing Errors</a> for error handling details. <br />
 <br />
 This is an example of loading XML document from file: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Document.html">Mezzanine::XML::Document</a> Doc;</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> Result = Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a89365dd7aa1cd2e25ebd72ceae8cad90">LoadFile</a>(<span class="stringliteral">&quot;tree.xml&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Load result: &quot;</span> &lt;&lt; Result.<a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html#ab67feece0af7c9fd2622cd83070833f2">Description</a>() &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLLoadingFromMemory"></a>
Loading document from memory</h2>
<p>Sometimes XML data should be loaded from some other source than a file, i.e. HTTP URL; also you may want to load XML data from file using non-standard functions, i.e. to use your virtual file system facilities or to load XML from gzip-compressed files. All these scenarios require loading document from memory. First you should prepare a contiguous memory block with all XML data; then you have to invoke one of buffer loading functions. These functions will handle the necessary encoding conversions, if any, and then will parse the data into the corresponding XML tree. There are several buffer loading functions, which differ in the behavior and thus in performance/memory usage: </p><div class="fragment"><div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a98977b675efa58d56c224f6256800127">Mezzanine::XML::Document::LoadBuffer</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options=<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>);</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a8be0ede460622c63de94b734bc258ab6">Mezzanine::XML::Document::LoadBufferInplace</a> (<span class="keywordtype">void</span> *contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options=<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>);</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a30fdca5c7cacb1cceff28e03f5b27850">Mezzanine::XML::Document::LoadBufferInplaceOwn</a> (<span class="keywordtype">void</span> *contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options=<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>)</div>
</div><!-- fragment --><p> All functions accept the buffer which is represented by a pointer to XML data, contents, and data size in bytes. Also there are two optional arguments, which specify parsing options ( see <a class="el" href="XMLManual.html#XMLLoadingParsingOptions">Parsing Options</a> ) and input data encoding ( see <a class="el" href="XMLManual.html#XMLLoadingEncodings">Encodings</a> ). The buffer does not have to be zero-terminated. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a98977b675efa58d56c224f6256800127" title="Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the func...">Mezzanine::XML::Document::LoadBuffer</a> function works with immutable buffer - it does not ever modify the buffer. Because of this restriction it has to create a private buffer and copy XML data to it before parsing (applying encoding conversions if necessary). This copy operation carries a performance penalty, so inplace functions are provided - <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a8be0ede460622c63de94b734bc258ab6" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Mezzanine::XML::Document::LoadBufferInplace</a> and <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a30fdca5c7cacb1cceff28e03f5b27850" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Mezzanine::XML::Document::LoadBufferInplaceOwn</a> store the document data in the buffer, modifying it in the process. In order for the document to stay valid, you have to make sure that the buffer's lifetime exceeds that of the tree if you're using inplace functions. In addition to that, <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a8be0ede460622c63de94b734bc258ab6" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Mezzanine::XML::Document::LoadBufferInplace</a> does not assume ownership of the buffer, so you'll have to destroy it yourself; <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a30fdca5c7cacb1cceff28e03f5b27850" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Mezzanine::XML::Document::LoadBufferInplaceOwn</a> assumes ownership of the buffer and destroys it once it is not needed. This means that if you're using <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a30fdca5c7cacb1cceff28e03f5b27850" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Mezzanine::XML::Document::LoadBufferInplaceOwn</a>, you have to allocate memory with Mezzanine::xml allocation function ( Not recomended, the Allocation API may be getting updates in the near future ). <br />
 <br />
 The best way from the performance/memory point of view is to load document using <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a30fdca5c7cacb1cceff28e03f5b27850" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Mezzanine::XML::Document::LoadBufferInplaceOwn</a>; this function has maximum control of the buffer with XML data so it is able to avoid redundant copies and reduce peak memory usage while parsing. However, this is not recommendeded unless you have to load the document from memory and performance is critical. Once the memory portion of the API has stabilized this will become the ideal <br />
 <br />
 There is also a simple helper function for cases when you want to load the XML document from null-terminated character string: </p><div class="fragment"><div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Mezzanine::XML::Document::Load</a>(<span class="keyword">const</span> char_t *contents, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options=<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>);</div>
</div><!-- fragment --><p> It is equivalent to calling <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a98977b675efa58d56c224f6256800127" title="Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the func...">Mezzanine::XML::Document::LoadBuffer</a> with size being either strlen(contents) or wcslen(contents) * sizeof(wchar_t), depending on the character type. This function assumes native encoding for input data, so it does not do any encoding conversion. In general, this function is fine for loading small documents from string literals, but has more overhead and less functionality than the buffer loading functions. <br />
 <br />
 This is an example of loading XML document from memory using LoadBuffer: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> Source[] = <span class="stringliteral">&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;</span>;</div>
<div class="line"><span class="keywordtype">size_t</span> Size = <span class="keyword">sizeof</span>(Source);</div>
<div class="line"></div>
<div class="line"><span class="comment">// You can use LoadBuffer to load the document from an immutable memory block:</span></div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> Result = doc.LoadBuffer(Source, Size);</div>
</div><!-- fragment --><p> This is an example of loading XML document from memory using LoadBufferInplace: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> Source[] = <span class="stringliteral">&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;</span>;</div>
<div class="line"><span class="keywordtype">size_t</span> Size = <span class="keyword">sizeof</span>(Source);</div>
<div class="line"></div>
<div class="line"><span class="comment">// You can use LoadBufferInplace to load document from mutable memory block</span></div>
<div class="line"><span class="comment">// the block&#39;s lifetime must exceed that of document</span></div>
<div class="line"><span class="keywordtype">char</span>* Buffer = <span class="keyword">new</span> <span class="keywordtype">char</span>[Size];</div>
<div class="line">memcpy(Buffer, Source, Size);</div>
<div class="line"></div>
<div class="line"><span class="comment">// The block can be allocated by any method; the block is modified during parsing</span></div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> Result = doc.LoadBufferInplace(Buffer, Size);</div>
<div class="line"></div>
<div class="line"><span class="comment">// You have to destroy the block yourself after the document is no longer used</span></div>
<div class="line"><span class="keyword">delete</span>[] Buffer;</div>
</div><!-- fragment --><p> This is an example of loading XML document from memory using Load and a string literal: </p><div class="fragment"><div class="line"><span class="comment">// You can use Load to load document from null-terminated strings, for example literals:</span></div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> Result = doc.Load(<span class="stringliteral">&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;</span>);</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLLoadingStreams"></a>
Loading document from C++ IOstreams</h2>
<p>To enhance interoperability, Mezzanine::xml provides functions for loading document from any object which implements C++ std::istream interface. This allows you to load documents from any standard C++ stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). There are two functions, one works with narrow character streams, another handles wide character ones: </p><div class="fragment"><div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Mezzanine::XML::Document::Load</a> (std::basic_istream&lt; <span class="keywordtype">char</span>, std::char_traits&lt; char &gt; &gt; &amp;stream, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options=<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>);</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Mezzanine::XML::Document::Load</a> (std::basic_istream&lt; <span class="keywordtype">wchar_t</span>, std::char_traits&lt; wchar_t &gt; &gt; &amp;stream, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options=<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">ParseDefault</a>);</div>
</div><!-- fragment --><p> <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721" title="Load XML from a stream. ">Mezzanine::XML::Document::Load</a> with std::istream argument loads the document from stream from the current read position to the end, treating the stream contents as a byte stream of the specified encoding (with encoding autodetection as necessary). Thus calling <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721" title="Load XML from a stream. ">Mezzanine::XML::Document::Load</a> on an opened std::ifstream object is equivalent to calling <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a89365dd7aa1cd2e25ebd72ceae8cad90" title="Load document from file. ">Mezzanine::XML::Document::LoadFile</a>. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721" title="Load XML from a stream. ">Mezzanine::XML::Document::Load</a> with std::wstream argument treats the stream contents as a wide character stream ( encoding is always <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::Encodingwchar_t</a> ). Because of this, using <a class="el" href="classMezzanine_1_1XML_1_1Document.html#a89365dd7aa1cd2e25ebd72ceae8cad90" title="Load document from file. ">Mezzanine::XML::Document::LoadFile</a> with wide character streams requires careful (usually platform-specific) stream setup (i.e. using the imbue function). Generally use of wide streams is discouraged, however it provides you the ability to load documents from non-Unicode encodings, i.e. you can load Shift-JIS encoded data if you set the correct locale. <br />
 <br />
 This is a simple example of loading XML document from a file using streams read: </p><div class="fragment"><div class="line">std::ifstream Stream(<span class="stringliteral">&quot;weekly-utf-8.xml&quot;</span>);</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> Result = Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(Stream);</div>
</div><!-- fragment --><p> Stream loading requires working seek/tell functions and therefore may fail when used with some stream implementations like gzstream. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLLoadingErrors"></a>
Handling Parsing Errors</h2>
<p>All document loading functions return the parsing result via <a class="el" href="structMezzanine_1_1XML_1_1ParseResult.html" title="Troubleshooting data intended to help troublshoot XML parsing errors. ">Mezzanine::XML::ParseResult</a> object. It contains parsing status, the offset of last successfully parsed character from the beginning of the source stream, and the encoding of the source stream. <br />
 <br />
 Parsing status is represented as the <a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442" title="These statuses are used to help determine what issues, if any the parser had. Returned by Mezzanine::...">Mezzanine::XML::ParseStatus</a> enumeration and can be one of the following:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusOk</a> means that no error was encountered during parsing; the source stream represents the valid XML document which was fully parsed and converted to a tree.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusFileNotFound</a> is only returned by Document::LoadFile function and means that file could not be opened.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusIOError</a> is returned by Document::LoadFile function and by load functions with std::istream/std::wstream arguments; it means that some I/O error has occurred during reading the file/stream.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusOutOfMemory</a> means that there was not enough memory during some allocation; any allocation failure during parsing results in this error.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusInternalError</a> means that something went horribly wrong; currently this error does not occur.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusUnrecognizedTag</a> means that parsing stopped due to a tag with either an empty name or a name which starts with incorrect character, such as #.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusBadPi</a> means that parsing stopped due to incorrect document declaration/processing instruction.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusBadComment, StatusBadCdata, StatusBadDocType and StatusBadPcdata</a> mean that parsing stopped due to the invalid construct of the respective type</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusBadStartElement</a> means that parsing stopped because starting tag either had no closing &gt; symbol or contained some incorrect symbol</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusBadAttribute</a> means that parsing stopped because there was an incorrect attribute, such as an attribute without value or with value that is not quoted (note that &lt;node attr=1&gt; is incorrect in XML)</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusBadEndElement</a> means that parsing stopped because ending tag had incorrect syntax (i.e. extra non-whitespace symbols between tag name and &gt;)</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a25d44cacbf75a9d031eae1baa9481442">ParseStatus::StatusEndElementMismatch</a> means that parsing stopped because the closing tag did not match the opening one (i.e. &lt;node&gt;&lt;/nedo&gt;) or because some tag was not closed at all.</li>
</ul>
<p><a class="el" href="structMezzanine_1_1XML_1_1ParseResult.html#ab67feece0af7c9fd2622cd83070833f2" title="Get error Description. ">Mezzanine::XML::ParseResult::Description</a> member function can be used to convert parsing status to a string; the returned message is always in English, so you'll have to write your own function if you need a localized string. However please note that the exact messages returned by the Description() function may change from version to version, so any complex status handling should be based on the Status value. <br />
 <br />
 If parsing failed because the source data was not a valid XML, the resulting tree is not destroyed - despite the fact that load function returns error, you can use the part of the tree that was successfully parsed. Obviously, the last element may have an unexpected name/value; for example, if the attribute value does not end with the necessary quotation mark, like in &lt;node attr="value&gt;some data&lt;/node&gt; example, the value of attribute attr will contain the string "value&gt;some data&lt;/node&gt;". <br />
 <br />
 In addition to the Status code, <a class="el" href="structMezzanine_1_1XML_1_1ParseResult.html" title="Troubleshooting data intended to help troublshoot XML parsing errors. ">Mezzanine::XML::ParseResult</a> has an Offset member, which contains the offset of last successfully parsed character if parsing failed because of an error in source data; otherwise offset is 0. For parsing efficiency reasons, Mezzanine::xml does not track the current line during parsing; this offset is in units of Mezzanine::XML::char_t (bytes for character mode, wide characters for wide character mode). Many text editors support 'Go To Position' feature - you can use it to locate the exact error position. Alternatively, if you're loading the document from memory, you can display the error chunk along with the error description. </p><dl class="section warning"><dt>Warning</dt><dd>Offset is calculated in the XML buffer in native encoding; if encoding conversion is performed during parsing, offset can not be used to reliably track the error position.</dd></dl>
<p><a class="el" href="structMezzanine_1_1XML_1_1ParseResult.html" title="Troubleshooting data intended to help troublshoot XML parsing errors. ">Mezzanine::XML::ParseResult</a> also has a DocumentEncoding member, which can be used to check that the source data encoding was correctly guessed. It is equal to the exact encoding used during parsing (i.e. with the exact endianness); see <a class="el" href="XMLManual.html#XMLLoadingEncodings">Encodings</a> for more information. <br />
 <br />
 A <a class="el" href="structMezzanine_1_1XML_1_1ParseResult.html" title="Troubleshooting data intended to help troublshoot XML parsing errors. ">Mezzanine::XML::ParseResult</a> object can be implicitly converted to bool; if you do not want to handle parsing errors thoroughly, you can just check the return value of load functions as if it was a bool: if (doc.load_file("file.xml")) { //on Successful parse } else { //on failed parse }. A True is returned if parsing was successful. <br />
 <br />
 This is an example of handling loading errors: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> Source[] = <span class="stringliteral">&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Document.html">Mezzanine::XML::Document</a> Doc;</div>
<div class="line"><a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> Result = Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(Source);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (Result)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;XML [&quot;</span> &lt;&lt; Source &lt;&lt; <span class="stringliteral">&quot;] parsed without errors\n\n&quot;</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;XML [&quot;</span> &lt;&lt; Source &lt;&lt; <span class="stringliteral">&quot;] parsed with errors\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error description: &quot;</span> &lt;&lt; Result.<a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html#ab67feece0af7c9fd2622cd83070833f2">Description</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error offset: &quot;</span> &lt;&lt; Result.<a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html#ae67c011303a234f2b3984584f3d4a6ff">Offset</a> &lt;&lt; <span class="stringliteral">&quot; (error at [...&quot;</span> &lt;&lt; (Source + Result.<a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html#ae67c011303a234f2b3984584f3d4a6ff">Offset</a>) &lt;&lt; <span class="stringliteral">&quot;]\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLLoadingParsingOptions"></a>
Parsing Options</h2>
<p>All document loading functions accept the optional parameter options. This is a bitmask that customizes the parsing process: you can select the node types that are parsed and various transformations that are performed with the XML text. Disabling certain transformations can improve parsing performance for some documents; however, the code for all transformations is very well optimized, and thus the majority of documents won't get any performance benefit. As a general rule, only modify parsing flags if you want to get some nodes in the document that are excluded by default (i.e. declaration or comment nodes). </p><dl class="section note"><dt>Note</dt><dd>You should use the usual bitwise arithmetic to manipulate the bitmask: to enable a flag, use mask | flag; to disable a flag, use mask &amp; ~flag.</dd></dl>
<p>These flags control the resulting tree contents:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a8f36bcf2332a3393c6bb437f080e7468">Mezzanine::XML::ParseDeclaration</a> determines if XML document declaration (node with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDeclaration</a> ) is to be put in DOM tree. If this flag is off, it is not put in the tree, but is still parsed and checked for correctness. This flag is off by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a9a5951b276f36d8260f299b0dad23dfd">Mezzanine::XML::ParseDocType</a> determines if XML document type declaration (node with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDocType</a> ) is to be put in DOM tree. If this flag is off, it is not put in the tree, but is still parsed and checked for correctness. This flag is off by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a10dfe21f7a8edcd95c34de367b723a1e">Mezzanine::XML::ParsePi</a> determines if processing instructions (nodes with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePi</a> ) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. Note that "&lt;?xml ...?&gt;" (document declaration) is not considered to be a PI. This flag is off by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#aa47eb6ac501513239cda4ff7b23f6786">Mezzanine::XML::ParseComments</a> determines if comments (nodes with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeComment</a> ) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. This flag is off by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a4504643b4b1ad4cd0ed85fb42b25e1a4">Mezzanine::XML::ParseCdata</a> determines if CDATA sections (nodes with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeCdata</a> ) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. This flag is on by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#ad154251a7def4608431a84fdeef8e8d6">Mezzanine::XML::ParseWsPcdata</a> determines if PCDATA nodes (nodes with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePcdata</a> ) that consist only of whitespace characters are to be put in DOM tree. Often whitespace-only data is not significant for the application, and the cost of allocating and storing such nodes (both memory and speed-wise) can be significant. For example, after parsing XML string "&lt;node&gt; &lt;a/&gt; &lt;/node&gt;, &lt;node&gt;" element will have three children when <a class="el" href="namespaceMezzanine_1_1XML.html#ad154251a7def4608431a84fdeef8e8d6" title="This flag determines if plain character data (NodePcdata) that consist only of whitespace are added t...">Mezzanine::XML::ParseWsPcdata</a> is set (child with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePcdata</a> and value " ", child with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeElement</a> and name "a", and another child with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePcdata</a> and value " "), and only one child when <a class="el" href="namespaceMezzanine_1_1XML.html#ad154251a7def4608431a84fdeef8e8d6" title="This flag determines if plain character data (NodePcdata) that consist only of whitespace are added t...">Mezzanine::XML::ParseWsPcdata</a> is not set. This flag is off by default.</li>
</ul>
<p>These flags control the transformation of tree element contents:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#ad8eec3ecbd62fc333bd51abf0e0d4031">Mezzanine::XML::ParseEscapes</a> determines if character and entity references are to be expanded during the parsing process. Character references have the form &amp;#...; or &amp;#x...; (... is Unicode numeric representation of character in either decimal ( &amp;#...; ) or hexadecimal ( &amp;#x...; ) form), entity references are &amp;lt;, &amp;gt;, &amp;amp;, &amp;apos; and &amp;quot; (note that as Mezzanine::xml does not handle DTD, the only allowed entities are predefined ones). If character/entity reference can not be expanded, it is left as is, so you can do additional processing later. Reference expansion is performed on attribute values and PCDATA content. This flag is on by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a3f5fea4e887be7ff1796b8a1150f1f0a">Mezzanine::XML::ParseEol</a> determines if EOL handling (that is, replacing sequences 0x0d 0x0a by a single 0x0a character, and replacing all standalone 0x0d characters by 0x0a) is to be performed on input data (that is, comments contents, PCDATA/CDATA contents and attribute values). If this is set all \r \n will replaced with \n. This flag is on by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a06f0f3c1d26e2fb874d50d5ac48a0937">Mezzanine::XML::ParseWconvAttribute</a> determines if attribute value normalization should be performed for all attributes. This means, that whitespace characters (new line, tab and space) are replaced with space (' '). New line characters are always treated as if <a class="el" href="namespaceMezzanine_1_1XML.html#a3f5fea4e887be7ff1796b8a1150f1f0a" title="This flag determines if EOL characters are normalized (converted to #xA) during parsing. This flag is on by default. ">Mezzanine::XML::ParseEol</a> is set, i.e. \r \n is converted to a single space. This flag is on by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#ad4f5c38b3b86855050a6b1b92b771612">Mezzanine::XML::ParseWnormAttribute</a> determines if extended attribute value normalization should be performed for all attributes. This means, that after attribute values are normalized as if <a class="el" href="namespaceMezzanine_1_1XML.html#a06f0f3c1d26e2fb874d50d5ac48a0937" title="This flag determines if attribute values are normalized using CDATA normalization rules during parsin...">Mezzanine::XML::ParseWconvAttribute</a> was set, leading and trailing space characters are removed, and all sequences of space characters are replaced by a single space character. The value of <a class="el" href="namespaceMezzanine_1_1XML.html#a06f0f3c1d26e2fb874d50d5ac48a0937" title="This flag determines if attribute values are normalized using CDATA normalization rules during parsin...">Mezzanine::XML::ParseWconvAttribute</a> was set has no effect if this flag is on. This flag is off by default.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespaceMezzanine_1_1XML.html#a06f0f3c1d26e2fb874d50d5ac48a0937" title="This flag determines if attribute values are normalized using CDATA normalization rules during parsin...">Mezzanine::XML::ParseWconvAttribute</a> option performs transformations that are required by W3C specification for attributes that are declared as CDATA; ParseWnormAttribute performs transformations required for NMTOKENS attributes. In the absence of document type declaration all attributes should behave as if they are declared as CDATA, thus <a class="el" href="namespaceMezzanine_1_1XML.html#a06f0f3c1d26e2fb874d50d5ac48a0937" title="This flag determines if attribute values are normalized using CDATA normalization rules during parsin...">Mezzanine::XML::ParseWconvAttribute</a> is the default option.</dd></dl>
<p>Additionally there are three predefined option masks:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a019d452f24324f76f236257eaf1ffb9b" title="Minimal parsing mode (equivalent to turning all other flags off). ">Mezzanine::XML::ParseMinimal</a> has all options turned off. This option mask means that Mezzanine::xml does not add declaration nodes, document type declaration nodes, PI nodes, CDATA sections and comments to the resulting tree and does not perform any conversion for input data, so theoretically it is the fastest mode. However, as mentioned above, in practice <a class="el" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21" title="The default parsing mode. ">Mezzanine::XML::ParseDefault</a> is usually equally fast.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21" title="The default parsing mode. ">Mezzanine::XML::ParseDefault</a> is the default set of flags, i.e. it has all options set to their default values. It includes parsing CDATA sections (comments/PIs are not parsed), performing character and entity reference expansion, replacing whitespace characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections consisting only of whitespace characters are not parsed (by default) for performance reasons.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a10efc4e566d550841245774e21ee98ae" title="The full parsing mode. ">Mezzanine::XML::ParseFull</a> is the set of flags which adds nodes of all types to the resulting tree and performs default conversions for input data. It includes parsing CDATA sections, comments, PI nodes, document declaration node and document type declaration node, performing character and entity reference expansion, replacing whitespace characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections consisting only of whitespace characters are not parsed in this mode.</li>
</ul>
<p>This is an example of using different parsing options: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* Source = <span class="stringliteral">&quot;&lt;!--comment--&gt;&lt;node&gt;&amp;lt;&lt;/node&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Parsing with default options; note that comment node is not added to the tree, and entity reference &amp;lt; is expanded</span></div>
<div class="line">Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(Source);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;First node value: [&quot;</span> &lt;&lt; Doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">GetFirstChild</a>().<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Value</a>() &lt;&lt; <span class="stringliteral">&quot;], node child value: [&quot;</span> &lt;&lt; Doc.ChildValue(<span class="stringliteral">&quot;node&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Parsing with additional value option; comment node is now added to the tree</span></div>
<div class="line">Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(Source, <a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">Mezzanine::XML::ParseDefault</a> | <a class="code" href="namespaceMezzanine_1_1XML.html#aa47eb6ac501513239cda4ff7b23f6786">Mezzanine::XML::ParseComments</a>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;First node value: [&quot;</span> &lt;&lt; Doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">GetFirstChild</a>().<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Value</a>() &lt;&lt; <span class="stringliteral">&quot;], node child value: [&quot;</span> &lt;&lt; Doc.ChildValue(<span class="stringliteral">&quot;node&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Parsing with additional value option and without the (default) parse_escapes option; &amp;lt; is not expanded</span></div>
<div class="line">Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(Source, (<a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">Mezzanine::XML::ParseDefault</a> | <a class="code" href="namespaceMezzanine_1_1XML.html#aa47eb6ac501513239cda4ff7b23f6786">Mezzanine::XML::ParseComments</a>) &amp; ~<a class="code" href="namespaceMezzanine_1_1XML.html#ad8eec3ecbd62fc333bd51abf0e0d4031">Mezzanine::XML::ParseEscapes</a>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;First node value: [&quot;</span> &lt;&lt; Doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">GetFirstChild</a>().<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Value</a>() &lt;&lt; <span class="stringliteral">&quot;], node child value: [&quot;</span> &lt;&lt; Doc.ChildValue(<span class="stringliteral">&quot;node&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Parsing with minimal option mask; comment node is not added to the tree, and &amp;lt; is not expanded</span></div>
<div class="line">Doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(Source, <a class="code" href="namespaceMezzanine_1_1XML.html#a019d452f24324f76f236257eaf1ffb9b">Mezzanine::XML::ParseMinimal</a>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;First node value: [&quot;</span> &lt;&lt; Doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">GetFirstChild</a>().<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Value</a>() &lt;&lt; <span class="stringliteral">&quot;], node child value: [&quot;</span> &lt;&lt; Doc.ChildValue(<span class="stringliteral">&quot;node&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLLoadingEncodings"></a>
Encodings</h2>
<p>Mezzanine::xml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it's a strict subset of UTF-16) and handles all encoding conversions. Most loading functions accept the optional parameter encoding. This is a value of enumeration type <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057" title="These flags determine the encoding of input data for an XML document. ">Mezzanine::XML::Encoding</a>, that can have the following values:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingAuto</a> means that pugixml will try to guess the encoding based on source XML data. The algorithm is a modified version of the one presented in Appendix F.1 of XML recommendation; it tries to match the first few bytes of input data with the following patterns in strict order:<ul>
<li>If first four bytes match UTF-32 BOM (Byte Order Mark), encoding is assumed to be UTF-32 with the endianness equal to that of BOM;</li>
<li>If first two bytes match UTF-16 BOM, encoding is assumed to be UTF-16 with the endianness equal to that of BOM;</li>
<li>If first three bytes match UTF-8 BOM, encoding is assumed to be UTF-8;</li>
<li>If first four bytes match UTF-32 representation of &lt;, encoding is assumed to be UTF-32 with the corresponding endianness;</li>
<li>If first four bytes match UTF-16 representation of &lt;?, encoding is assumed to be UTF-16 with the corresponding endianness;</li>
<li>If first two bytes match UTF-16 representation of &lt;, encoding is assumed to be UTF-16 with the corresponding endianness (this guess may yield incorrect result, but it's better than UTF-8);</li>
<li>Otherwise encoding is assumed to be UTF-8.</li>
</ul>
</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF8</a> corresponds to UTF-8 encoding as defined in the Unicode standard; UTF-8 sequences with length equal to 5 or 6 are not standard and are rejected.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF16LE</a> corresponds to little-endian UTF-16 encoding as defined in the Unicode standard; surrogate pairs are supported.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF16BE</a> corresponds to big-endian UTF-16 encoding as defined in the Unicode standard; surrogate pairs are supported.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF16</a> corresponds to UTF-16 encoding as defined in the Unicode standard; the endianness is assumed to be that of the target platform.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF32LE</a> corresponds to little-endian UTF-32 encoding as defined in the Unicode standard.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF32BE</a> corresponds to big-endian UTF-32 encoding as defined in the Unicode standard.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::EncodingUTF32</a> corresponds to UTF-32 encoding as defined in the Unicode standard; the endianness is assumed to be that of the target platform.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::Encodingwchar_t </a> corresponds to the encoding of Mezzanine::XML::wchar_t type; it has the same meaning as either <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">EncodingUTF16</a> or <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">EncodingUTF32</a>, depending on Mezzanine::XML::wchar_t size.</li>
</ul>
<p>The algorithm used for <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">EncodingAuto</a> correctly detects any supported Unicode encoding for all well-formed XML documents (since they start with document declaration) and for all other XML documents that start with &lt;; if your XML document does not start with &lt; and has encoding that is different from UTF-8, use the specific encoding. </p><dl class="section note"><dt>Note</dt><dd>The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; moreover, in case no encoding conversion is performed, the invalid sequences are not removed, so you'll get them as is in node/attribute contents.</dd></dl>
<h2><a class="anchor" id="XMLLoadingStandards"></a>
Conformance to W3C Specification</h2>
<p>Mezzanine::xml is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid XML documents, some validation is not performed because of performance reasons. <br />
 <br />
 There is only one non-conformant behavior when dealing with valid XML documents, Mezzanine::xml does not use information supplied in document type declaration for parsing. This means that entities declared in DOCTYPE are not expanded, and all attribute/PCDATA values are always processed in a uniform way that depends only on parsing options. <br />
 <br />
 As for rejecting invalid XML documents, there are a number of incompatibilities with W3C specification, including:</p><ul>
<li>Multiple attributes of the same node can have equal names.</li>
<li>All non-ASCII characters are treated in the same way as symbols of English alphabet, so some invalid tag names are not rejected.</li>
<li>Attribute values which contain &lt; are not rejected.</li>
<li>Invalid entity/character references are not rejected and are instead left as is.</li>
<li>Comment values can contain &ndash;.</li>
<li>XML data is not required to begin with document declaration; additionally, document declaration can appear after comments and other nodes.</li>
<li>Invalid document type declarations are silently ignored in some cases.</li>
</ul>
<h1><a class="anchor" id="XMLAccessing"></a>
Accessing Document Data</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLAccessingBasics">Basic traversal functions</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingNodeData">Getting Node Data</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingAttributeData">Getting attribute data</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingContentBased">Content Based Traversal Functions</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingIterators">Traversing Node/Attribute Lists via Iterators</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingWalker">Recursive traversal with Mezzanine::XML::TreeWalker</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingPredicates">Searching for Nodes/Attributes with Predicates</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingMisc">Miscellaneous functions</a></li>
</ul>
<p>Mezzanine::xml features an extensive interface for getting various types of data from the document and for traversing the document. This section provides documentation for all such functions that do not modify the tree except for XPath-related functions; see <a class="el" href="XMLManual.html#XMLXPath">XPath</a> for XPath reference. As discussed in <a class="el" href="XMLManual.html#XMLInterface">C++ interface</a>, there are two types of handles to tree data - <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> and <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a>. The handles have special null (empty) values which propagate through various functions and thus are useful for writing more concise code; see <a class="el" href="XMLManual.html#XMLInterface">C++ interface</a> for details. The documentation in this section will explicitly state the results of all function in case of null inputs. </p>
<h2><a class="anchor" id="XMLAccessingBasics"></a>
Basic traversal functions</h2>
<p>The internal representation of the document is a tree, where each node has a list of child nodes (the order of children corresponds to their order in the XML representation), additionally element nodes have a list of attributes, which is also ordered. Several functions are provided in order to let you get from one node in the tree to the other. These functions roughly correspond to the internal representation, and thus are usually building blocks for other methods of traversing (i.e. XPath traversals are based on these functions). </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#add9d49e423ff030e92112b6fdfa2a980">Mezzanine::XML::Node::GetParent</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">Mezzanine::XML::Node::GetFirstChild</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ae26ccc6da396c9adf3309c781f81fed5">Mezzanine::XML::Node::GetLastChild</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9afd9eed67cd16754edaf6264021b21b">Mezzanine::XML::Node::GetNextSibling</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#afce3d7436e0da9b53e5b3168035e3daa">Mezzanine::XML::Node::GetPreviousSibling</a>() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a380e93db12d1b50caff852e86f1c3e84">Mezzanine::XML::Node::GetFirstAttribute</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a85c34a02ae07edea04a6371f173c9e51">Mezzanine::XML::Node::GetLastAttribute</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a91f5a17b436820fe941736a041a5ee48">Mezzanine::XML::Attribute::GetNextAttribute</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a80fe087c8e46dc54d85cdf7a0d30bce0">Mezzanine::XML::Attribute::GetPreviousAttribute</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The GetParent function returns the node's parent; all non-null nodes except the document have non-null parent. GetFirstChild and GetLastChild return the first and last child of the node, respectively; note that only document nodes and element nodes can have non-empty child node list. If node has no children, both functions return null nodes. GetNextSibling and GetPreviousSibling return the node that's immediately to the right/left of this node in the children list, respectively - for example, in &lt;a/&gt; &lt;b/&gt; &lt;c/&gt;, calling GetNextSibling for a handle that points to &lt;b/&gt; results in a handle pointing to &lt;c/&gt;, and calling GetPreviousSibling results in handle pointing to &lt;a/&gt;. If node does not have next/previous sibling (this happens if it is the last/first node in the list, respectively), the functions return null nodes. GetFirstAttribute, GetLastAttribute, GetNextAttribute and GetPreviousAttribute functions behave similarly to the corresponding child node functions and allow to iterate through attribute list in the same way. </p><dl class="section note"><dt>Note</dt><dd>Because of memory consumption reasons, attributes do not have a link to their parent nodes. Thus there is no Mezzanine::XML::attribute::parent() function.</dd></dl>
<p>Calling any of the functions above on the null handle results in a null handle - i.e. node.GetFirstChild().GetNextSibling() returns the second child of node, and null handle if node is null, has no children at all or if it has only one child node. <br />
 <br />
 With these functions, you can iterate through all child nodes and display all attributes like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> tool = tools.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">GetFirstChild</a>(); tool; tool = tool.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9afd9eed67cd16754edaf6264021b21b">GetNextSibling</a>())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Tool:&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> attr = tool.GetFirstAttribute(); attr; attr = attr.<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a91f5a17b436820fe941736a041a5ee48">GetNextAttribute</a>())</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; attr.Name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; attr.Value();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLAccessingNodeData"></a>
Getting Node Data</h2>
<p>Apart from structural information (parent, child nodes, attributes), nodes can have name and value, both of which are strings. Depending on node type, name or value may be absent. <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDocument</a> nodes do not have a name or value, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeElement</a> and <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDeclaration</a> nodes always have a name but never have a value, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodePcdata</a>, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeCdata</a>, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeComment</a> and <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocType</a> nodes never have a name but always have a value (it may be empty though), <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodePi</a> nodes always have a name and a value (again, value may be empty). In order to get node's name or value, you can use the following functions: </p><div class="fragment"><div class="line"><span class="keyword">const</span> char_t* <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ac1b2f6b9c5b1380c524e6a77011aeda4">Mezzanine::XML::Node::Name</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">const</span> char_t* <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Mezzanine::XML::Node::Value</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> In case node does not have a name or value or if the node handle is null, both functions return empty strings - they never return null pointers. <br />
 <br />
 It is common to store data as text contents of some node - i.e. &lt;node&gt; &lt;description&gt; This is a node &lt;/description&gt; &lt;/node&gt;. In this case, &lt;description&gt; node does not have a value, but instead has a child of type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodePcdata</a> with value "This is a node". Mezzanine::xml provides two helper functions to parse such data: </p><div class="fragment"><div class="line"><span class="keyword">const</span> char_t* Mezzanine::XML::Node::ChildValue() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">const</span> char_t* Mezzanine::XML::Node::ChildValue(<span class="keyword">const</span> char_t* name) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> ChildValue() returns the value of the first child with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodePcdata</a> or <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeCdata</a>; ChildValue(Name) is a simple wrapper for Child(Name).ChildValue(). For the above example, calling node.ChildValue("description") and description.ChildValue() will both produce string "This is a node". If there is no child with relevant type, or if the handle is null, ChildValue functions return empty string. <br />
 <br />
 There is an example of using some of these functions <a class="el" href="XMLManual.html#XMLAccessingAttributeData">at the end of the next section</a>. </p>
<h2><a class="anchor" id="XMLAccessingAttributeData"></a>
Getting attribute data</h2>
<p>All attributes have name and value, both of which are strings (value may be empty). There are two corresponding accessors: </p><div class="fragment"><div class="line"><span class="keyword">const</span> char_t* <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a068ada875a553ae409e501901bc05191">Mezzanine::XML::Attribute::Name</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">const</span> char_t* <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ac6e2e9cec855a3a69832b75c53f2de18">Mezzanine::XML::Attribute::Value</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> In case the attribute handle is null, both functions return empty strings - they never return null pointers. <br />
 <br />
 In many cases attribute values have types that are not strings - i.e. an attribute may always contain values that should be treated as integers, despite the fact that they are represented as strings in XML. Mezzanine::xml provides several accessors that convert attribute value to some other type: </p><div class="fragment"><div class="line"><span class="comment">// Native C++ types</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a4c95b188c053938505e3e770a311545c">Mezzanine::XML::Attribute::AsBool</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a09bfced7ac57e4c80af524a31561447b">Mezzanine::XML::Attribute::AsDouble</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a73ae5a32a8f10d3de238758e13840850">Mezzanine::XML::Attribute::AsFloat</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a433fef4f74eaa825755b53b1baea539a">Mezzanine::XML::Attribute::AsInt</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#affc4e62ae891b85fea0d34f90c5b18c9">Mezzanine::XML::Attribute::AsUint</a>() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Mezzanine abstracted types</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a4a8e7e953f94b05f8be0f0beb3ae1fe3">Mezzanine::XML::Attribute::AsReal</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#aeaf831643fd53fa7e645bf36b0a8ecec">Mezzanine::XML::Attribute::AsString</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="namespaceMezzanine.html#adcbb6ce6d1eb4379d109e51171e2e493">Whole</a> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ae5d2a5afd1559756172c5fbeadd3750b">Mezzanine::XML::Attribute::AsWhole</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> AsDouble, AsFloat, AsInt, AsUint, AsReal and AsWhole convert attribute values to numbers. If attribute handle is null or attribute value is empty, 0 is returned. Otherwise, all leading whitespace characters are truncated, and the remaining string is parsed as a decimal number (AsInt, AsUint or AsWhole) or as a floating point number in either decimal or scientific form (AsDouble, AsFloat or AsReal). Any extra characters are silently discarded, i.e. AsInt will return 1 for string "1abc". <br />
 <br />
 In case the input string contains a number that is out of the target numeric range, the result is undefined. </p><dl class="section warning"><dt>Warning</dt><dd>Some number conversion functions depend on current C locale as set with setlocale, so may return unexpected results if the locale is different from "C".</dd></dl>
<p>AsBool converts attribute value to boolean as follows: if attribute handle is null or attribute value is empty, false is returned. Otherwise, true is returned if the first character is one of '1', 't', 'T', 'y', 'Y'. This means that strings like "true" and "yes" are recognized as true, while strings like "false" and "no" are recognized as false. For more complex matching you'll have to write your own function. </p><dl class="section note"><dt>Note</dt><dd>There are no portable 64-bit types in C++, so there is no corresponding conversion function. If your platform has a 64-bit integer, you can easily write a conversion function yourself. We are planning on addressing this with a new <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> abstracted type, but we have not done so yet.</dd></dl>
<p>This is an example of using these functions, along with node data retrieval ones: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> tool = tools.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;Tool&quot;</span>); tool; tool = tool.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9afd9eed67cd16754edaf6264021b21b">GetNextSibling</a>(<span class="stringliteral">&quot;Tool&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Tool &quot;</span> &lt;&lt; tool.GetAttribute(<span class="stringliteral">&quot;Filename&quot;</span>).Value();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;: AllowRemote &quot;</span> &lt;&lt; tool.GetAttribute(<span class="stringliteral">&quot;AllowRemote&quot;</span>).AsBool();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, Timeout &quot;</span> &lt;&lt; tool.GetAttribute(<span class="stringliteral">&quot;Timeout&quot;</span>).AsInt();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, Description &#39;&quot;</span> &lt;&lt; tool.ChildValue(<span class="stringliteral">&quot;Description&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLAccessingContentBased"></a>
Content Based Traversal Functions</h2>
<p>Since a lot of document traversal consists of finding the node/attribute with the correct name, there are special functions for that purpose: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">Mezzanine::XML::Node::GetChild</a>(<span class="keyword">const</span> char_t* name) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">Mezzanine::XML::Node::GetAttribute</a>(<span class="keyword">const</span> char_t* name) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9afd9eed67cd16754edaf6264021b21b">Mezzanine::XML::Node::GetNextSibling</a>(<span class="keyword">const</span> char_t* name) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#afce3d7436e0da9b53e5b3168035e3daa">Mezzanine::XML::Node::GetPreviousSibling</a>(<span class="keyword">const</span> char_t* name) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> GetChild and GetAttribute return the first child/attribute with the specified name; GetNextSibling and GetPreviousSibling return the first sibling in the corresponding direction with the specified name. All string comparisons are case-sensitive. In case the node handle is null or there is no node/attribute with the specified name, null handle is returned. <br />
 <br />
 GetChild and GetNextSibling functions can be used together to loop through all child nodes with the desired name like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> tool = tools.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;Tool&quot;</span>); tool; tool = tool.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9afd9eed67cd16754edaf6264021b21b">GetNextSibling</a>(<span class="stringliteral">&quot;Tool&quot;</span>))</div>
<div class="line">    {}</div>
</div><!-- fragment --><p> Occasionally the needed node is specified not by the unique name but instead by the value of some attribute; for example, it is common to have node collections with each node having a unique id: &lt;group&gt; &lt;item id="1"/&gt; &lt;item id="2"/&gt; &lt;/group&gt;. There are two functions for finding child nodes based on the attribute values: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3a494ed0b7df6b44854631a2197c204a">Mezzanine::XML::Node::FindChildbyAttribute</a>(<span class="keyword">const</span> char_t* name, <span class="keyword">const</span> char_t* attr_name, <span class="keyword">const</span> char_t* attr_value) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3a494ed0b7df6b44854631a2197c204a">Mezzanine::XML::Node::FindChildbyAttribute</a>(<span class="keyword">const</span> char_t* attr_name, <span class="keyword">const</span> char_t* attr_value) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The three-argument function returns the first child node with the specified name which has an attribute with the specified name/value; the two-argument function skips the name test for the node, which can be useful for searching in heterogeneous collections. If the node handle is null or if no node is found, null handle is returned. All string comparisons are case-sensitive. <br />
 <br />
 In all of the above functions, all arguments have to be valid strings; passing null pointers results in undefined behavior.</p>
<p>This is an example of using these functions: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Tool for *.dae generation: &quot;</span> &lt;&lt; tools.FindChildbyAttribute(<span class="stringliteral">&quot;Tool&quot;</span>, <span class="stringliteral">&quot;OutputFileMasks&quot;</span>, <span class="stringliteral">&quot;*.dae&quot;</span>).GetAttribute(<span class="stringliteral">&quot;Filename&quot;</span>).Value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> tool = tools.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;Tool&quot;</span>); tool; tool = tool.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9afd9eed67cd16754edaf6264021b21b">GetNextSibling</a>(<span class="stringliteral">&quot;Tool&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Tool &quot;</span> &lt;&lt; tool.GetAttribute(<span class="stringliteral">&quot;Filename&quot;</span>).Value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLAccessingIterators"></a>
Traversing Node/Attribute Lists via Iterators</h2>
<p>Child node lists and attribute lists are simply double-linked lists; while you can use GetPreviousSibling/GetNextSibling and other such functions for iteration, Mezzanine::xml additionally provides node and attribute iterators, so that you can treat nodes as containers of other nodes or attributes: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classMezzanine_1_1XML_1_1NodeIterator.html">Mezzanine::XML::NodeIterator</a>;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMezzanine_1_1XML_1_1AttributeIterator.html">Mezzanine::XML::AttributeIterator</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classMezzanine_1_1XML_1_1NodeIterator.html">Mezzanine::XML::NodeIterator</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#afe6bd18eaf3ccafadaf851b0247019f3">Mezzanine::XML::Node::iterator</a>;</div>
<div class="line">iterator <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ac0ec690c89564f34967b5563fc335ffa">Mezzanine::XML::Node::begin</a>() <span class="keyword">const</span>;</div>
<div class="line">iterator <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aabffeb501cfdd732dc2ce6b1bda6c56f">Mezzanine::XML::Node::end</a>() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classMezzanine_1_1XML_1_1AttributeIterator.html">Mezzanine::XML::AttributeIterator</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a25bf6994d599bfa0e3f25b7215b78d4f">Mezzanine::XML::Node::attribute_iterator</a>;</div>
<div class="line">attribute_iterator <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a73b0f3df319f02e7fe7e2f71cdbef111">Mezzanine::XML::Node::attributes_begin</a>() <span class="keyword">const</span>;</div>
<div class="line">attribute_iterator <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a617646c65216350a24dec35ac6784aa8">Mezzanine::XML::Node::attributes_end</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> begin and attributes_begin return iterators that point to the first node/attribute, respectively; end and attributes_end return past-the-end iterator for node/attribute list, respectively - this iterator can't be dereferenced, but decrementing it results in an iterator pointing to the last element in the list (except for empty lists, where decrementing past-the-end iterator results in undefined behavior). Past-the-end iterator is commonly used as a termination value for iteration loops (see sample below). If you want to get an iterator that points to an existing handle, you can construct the iterator with the handle as a single constructor argument, like so: <a class="el" href="classMezzanine_1_1XML_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node) ">Mezzanine::XML::NodeIterator(node)</a>. For <a class="el" href="classMezzanine_1_1XML_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute). ">Mezzanine::XML::AttributeIterator</a>, you'll have to provide both an attribute and its parent node. <br />
 <br />
 begin and end return equal iterators if called on null node; such iterators can't be dereferenced. attributes_begin and attributes_end behave the same way. For correct iterator usage this means that child node/attribute collections of null nodes appear to be empty. </p><dl class="section note"><dt>Note</dt><dd>The names begin, end, attribute_begin and attribute_end were chosen for maximum compatibility. Some template functions that act on containers rely on the name begin and end. We may develop a naming scheme that fits better into the existing API in the future.</dd></dl>
<p>Both types of iterators have bidirectional iterator semantics (i.e. they can be incremented and decremented, but efficient random access is not supported) and support all usual iterator operations - comparison, dereference, etc. The iterators are invalidated if the node/attribute objects they're pointing to are removed from the tree; adding nodes/attributes does not invalidate any iterators. <br />
 <br />
 Here is an example of using iterators for document traversal: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1NodeIterator.html">Mezzanine::XML::NodeIterator</a> it = tools.begin(); it != tools.end(); ++it)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Tool:&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1AttributeIterator.html">Mezzanine::XML::AttributeIterator</a> ait = it-&gt;attributes_begin(); ait != it-&gt;attributes_end(); ++ait)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ait-&gt;Name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; ait-&gt;Value();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>Node and attribute iterators are somewhere in the middle between const and non-const iterators. While dereference operation yields a non-constant reference to the object, so that you can use it for tree modification operations, modifying this reference by assignment - i.e. passing iterators to a function like std::sort - will not give expected results, as assignment modifies local handle that's stored in the iterator.</dd></dl>
<h2><a class="anchor" id="XMLAccessingWalker"></a>
Recursive traversal with Mezzanine::XML::TreeWalker</h2>
<p>The methods described above allow traversal of immediate children of some node; if you want to do a deep tree traversal, you'll have to do it via a recursive function or some equivalent method. However, pugixml provides a helper for depth-first traversal of a subtree. In order to use it, you have to implement the <a class="el" href="classMezzanine_1_1XML_1_1TreeWalker.html" title="Used to call a function OnEachNode member of the subtree of nodes descended from a specific node...">Mezzanine::XML::TreeWalker</a> interface and to call the <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a60c011dca7c524ff915d1aa8a048a577" title="Perform sophisticated (or whatever) algorithms on this and all descendant Nodes in the XML tree...">Mezzanine::XML::Node::Traverse</a> function. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a60c011dca7c524ff915d1aa8a048a577">Mezzanine::XML::Node::Traverse</a>(<a class="code" href="classMezzanine_1_1XML_1_1TreeWalker.html">Mezzanine::XML::TreeWalker</a>&amp; walker);</div>
</div><!-- fragment --><p> The traversal is launched by calling traverse function on traversal root and proceeds as follows:</p><ul>
<li>First, TreeWalker::begin function is called with traversal root as its argument.</li>
<li>Then, TreeWalker::for_each function is called for all nodes in the traversal subtree in depth first order, excluding the traversal root. Node is passed as an argument.</li>
<li>Finally, TreeWalker::end function is called with traversal root as its argument.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The Names of the Treewalker could change without notice prior to the initial of the engine.</dd></dl>
<p>If begin, end or any of the for_each calls return false, the traversal is terminated and false is returned as the traversal result; otherwise, the traversal results in true. Note that you don't have to override begin or end functions; their default implementations return true. <br />
 <br />
 You can get the node's depth relative to the traversal root at any point by calling TreeWalker::Depth function. It returns -1 if called from begin/end, and returns 0-based depth if called from TreeWalker::for_each - depth is 0 for all children of the traversal root, 1 for all grandchildren and so on. <br />
 <br />
 This is an example of traversing tree hierarchy with <a class="el" href="classMezzanine_1_1XML_1_1TreeWalker.html" title="Used to call a function OnEachNode member of the subtree of nodes descended from a specific node...">Mezzanine::XML::TreeWalker</a>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>SimpleWalker: <a class="code" href="classMezzanine_1_1XML_1_1TreeWalker.html">Mezzanine::XML::TreeWalker</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> for_each(<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classMezzanine_1_1XML_1_1TreeWalker.html#a827e7aa4d768158cf615a6bf0586f33f">Depth</a>(); ++i) std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>; <span class="comment">// indentation</span></div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;: Name=&#39;&quot;</span> &lt;&lt; node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#ac1b2f6b9c5b1380c524e6a77011aeda4">Name</a>() &lt;&lt; <span class="stringliteral">&quot;&#39;, Value=&#39;&quot;</span> &lt;&lt; node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Value</a>() &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// continue traversal</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SimpleWalker walker;</div>
<div class="line">Doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a60c011dca7c524ff915d1aa8a048a577">Traverse</a>(walker);</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLAccessingPredicates"></a>
Searching for Nodes/Attributes with Predicates</h2>
<p>While there are existing functions for getting a node/attribute with known contents, they are often not sufficient for simple queries. As an alternative for manual iteration through nodes/attributes until the needed one is found, you can make a predicate and call one of Find functions: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Predicate&gt; <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9fccd8710362bf3f7e2b25e78f860ffd">Mezzanine::XML::Node::FindAttribute</a>(Predicate pred) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Predicate&gt; <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a52f9857da9b3b939895c8915286fd9ad">Mezzanine::XML::Node::FindChild</a>(Predicate pred) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Predicate&gt; <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a5b6592942502b7cc6b5eb19baef24b85">Mezzanine::XML::Node::FindNode</a>(Predicate pred) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The predicate should be either a plain function or a function object which accepts one argument of type <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> (for FindAttribute) or <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> (for FindChild and FindNode), and returns bool. The predicate is never called with null handle as an argument. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a9fccd8710362bf3f7e2b25e78f860ffd" title="Search for an Attribute using a function to check each Attribute individually. ">Mezzanine::XML::Node::FindAttribute</a> function iterates through all attributes of the specified node, and returns the first attribute for which the predicate returned true. If the predicate returned false for all attributes or if there were no attributes (including the case where the node is null), null attribute is returned. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a52f9857da9b3b939895c8915286fd9ad" title="Search for an child ( only direct children ) Node using a function to check each Node individually...">Mezzanine::XML::Node::FindChild</a> function iterates through all child nodes of the specified node, and returns the first node for which the predicate returned true. If the predicate returned false for all nodes or if there were no child nodes (including the case where the node is null), null node is returned. <br />
 <br />
 <a class="el" href="classMezzanine_1_1XML_1_1Node.html#a5b6592942502b7cc6b5eb19baef24b85" title="Search for any Node descended from this Node using a function to check each Node individually. ">Mezzanine::XML::Node::FindNode</a> function performs a depth-first traversal through the subtree of the specified node (excluding the node itself), and returns the first node for which the predicate returned true. If the predicate returned false for all nodes or if subtree was empty, null node is returned. <br />
 <br />
 Here are some sample predicates: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> SmallTimeout(<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> node)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;Timeout&quot;</span>).<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a433fef4f74eaa825755b53b1baea539a">AsInt</a>() &lt; 20;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>AllowRemotePredicate</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> attr)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> strcmp(attr.<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a068ada875a553ae409e501901bc05191">Name</a>(), <span class="stringliteral">&quot;AllowRemote&quot;</span>) == 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> node)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;AllowRemote&quot;</span>).<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a4c95b188c053938505e3e770a311545c">AsBool</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> This is an example of using predicate-based functions: </p><div class="fragment"><div class="line"><span class="comment">// Find child via predicate (looks for direct children only)</span></div>
<div class="line">std::cout &lt;&lt; tools.FindChild(AllowRemotePredicate()).GetAttribute(<span class="stringliteral">&quot;Filename&quot;</span>).Value() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Find node via predicate (looks for all descendants in depth-first order)</span></div>
<div class="line">std::cout &lt;&lt; doc.FindNode(AllowRemotePredicate()).GetAttribute(<span class="stringliteral">&quot;Filename&quot;</span>).Value() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Find attribute via predicate</span></div>
<div class="line">std::cout &lt;&lt; tools.LastChild().FindAttribute(AllowRemotePredicate()).Value() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// We can use simple functions instead of function objects</span></div>
<div class="line">std::cout &lt;&lt; tools.FindChild(SmallTimeout).GetAttribute(<span class="stringliteral">&quot;Filename&quot;</span>).Value() &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLAccessingMisc"></a>
Miscellaneous functions</h2>
<p>If you need to get the document root of some node, you can use the following function: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ae54eb76a1905fa6e4950ffc1e5ecb98a">Mezzanine::XML::Node::GetRoot</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> This function returns the node with type <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDocument</a>, which is the root node of the document the node belongs to (unless the node is null, in which case null node is returned). <br />
 <br />
 While Mezzanine::xml supports complex XPath expressions, sometimes a simple path handling facility is needed. There are two functions, for getting node path and for converting path to a node: </p><div class="fragment"><div class="line"><a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">Mezzanine::String</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aeb0e436aeafde484a33a362e507dfe64">Mezzanine::XML::Node::Path</a>(char_t delimiter = <span class="charliteral">&#39;/&#39;</span>) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a446781c040be454e12282ff91d28cb20">Mezzanine::XML::Node::FirstElementByPath</a>(<span class="keyword">const</span> char_t* Path, char_t delimiter = <span class="charliteral">&#39;/&#39;</span>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Node paths consist of node names, separated with a delimiter (which is / by default); also paths can contain self (.) and parent (..) pseudo-names, so that this is a valid path: "../../foo/./bar". path returns the path to the node from the document root, FirstElementByPath looks for a node represented by a given path; a path can be an absolute one (absolute paths start with the delimiter), in which case the rest of the path is treated as document root relative, and relative to the given node. For example, in the following document: &lt;a&gt; &lt;b&gt; &lt;c/&gt; &lt;/b&gt; &lt;/a&gt;, node &lt;c/&gt; has path "a/b/c"; calling FirstElementByPath for document with path "a/b" results in node &lt;b/&gt;; calling FirstElementByPath for node &lt;a/&gt; with path "../a/./b/../." results in node &lt;a/&gt;; calling FirstElementByPath with path "/a" results in node &lt;a/&gt; for any node. <br />
 <br />
 In case path component is ambiguous (if there are two nodes with given name), the first one is selected; paths are not guaranteed to uniquely identify nodes in a document. If any component of a path is not found, the result of FirstElementByPath is null node; also FirstElementByPath returns null node for null nodes, in which case the path does not matter. path returns an empty string for null nodes.</p>
<p>Mezzanine::xml does not record row/column information for nodes upon parsing for efficiency reasons. However, if the node has not changed in a significant way since parsing (the name/value are not changed, and the node itself is the original one, i.e. it was not deleted from the tree and re-added later), it is possible to get the offset from the beginning of XML buffer: </p><div class="fragment"><div class="line">ptrdiff_t Mezzanine::XML::node::OffSetDebug() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> If the offset is not available (this happens if the node is null, was not originally parsed from a stream, or has changed in a significant way), the function returns -1. Otherwise it returns the offset to node's data from the beginning of XML buffer in Mezzanine::XML::char_t units. For more information on parsing offsets, see parsing error handling documentation. <br />
 <br />
</p>
<h1><a class="anchor" id="XMLModifying"></a>
Modifiying Documents</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLModifyingNodeData">Setting Node Data</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingAttributeData">Setting Attribute Data</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingAdding">Adding Nodes/Attributes</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingRemoving">Removing Nodes/Attributes</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingCloning">Cloning Nodes/Attributes</a></li>
</ul>
<p>The document in Mezzanine::xml is fully mutable: you can completely change the document structure and modify the data of nodes/attributes. This section provides documentation for the relevant functions. All functions take care of memory management and structural integrity themselves, so they always result in structurally valid tree - however, it is possible to create an invalid XML tree (for example, by adding two attributes with the same name or by setting attribute/node name to empty/invalid string). Tree modification is optimized for performance and for memory consumption, so if you have enough memory you can create documents from scratch with Mezzanine::xml and later save them to file/stream instead of relying on error-prone manual text writing and without too much overhead. <br />
 <br />
 All member functions that change node/attribute data or structure are non-constant and thus can not be called on constant handles. However, you can easily convert constant handle to non-constant one by simple assignment: void foo(const Mezzanine::XML::Node&amp; n) { <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> nc = n; }, so const-correctness here mainly provides additional documentation. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLModifyingNodeData"></a>
Setting Node Data</h2>
<p>As discussed before, nodes can have name and value, both of which are c-strings. Depending on node type, name or value may be absent. <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDocument</a> nodes do not have a name or value, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeElement</a> and <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDeclaration</a> nodes always have a name but never have a value, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePcdata</a>, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeCdata</a>, <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeComment</a> and <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeDocType</a> nodes never have a name but always have a value (it may be empty though), <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePi</a> nodes always have a name and a value (again, value may be empty). In order to set node's name or value, you can use the following functions: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ae8a54e421843e865e7171d48f78be969">Mezzanine::XML::Node::SetName</a>(<span class="keyword">const</span> char_t* rhs);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ae8a54e421843e865e7171d48f78be969">Mezzanine::XML::Node::SetName</a>(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&amp; rhs);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa8bad1055873931e97cd12b044e838b4">Mezzanine::XML::Node::SetValue</a>(<span class="keyword">const</span> char_t* rhs);</div>
</div><!-- fragment --><p> Both functions try to set the name/value to the specified string, and return the operation result. The operation fails if the node can not have name or value (for instance, when trying to call SetName on a <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodePcdata</a> node), if the node handle is null, or if there is insufficient memory to handle the request. The provided string is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass stack-allocated buffers to these functions). The name/value content is not verified, so take care to use only valid XML names, or the document may become malformed. <br />
 <br />
 There is no equivalent of ChildValue function for modifying text children of the node. <br />
 <br />
 This is an example of setting node name and value: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> node = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;node&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// change node name</span></div>
<div class="line">std::cout &lt;&lt; node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#ae8a54e421843e865e7171d48f78be969">SetName</a>(<span class="stringliteral">&quot;notnode&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;, new node name: &quot;</span> &lt;&lt; node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#ac1b2f6b9c5b1380c524e6a77011aeda4">Name</a>() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// change comment text</span></div>
<div class="line">std::cout &lt;&lt; doc.GetLastChild().SetValue(<span class="stringliteral">&quot;useless comment&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;, new comment text: &quot;</span> &lt;&lt; doc.LastChild().Value() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// we can&#39;t change value of the element or name of the comment</span></div>
<div class="line">std::cout &lt;&lt; node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa8bad1055873931e97cd12b044e838b4">SetValue</a>(<span class="stringliteral">&quot;1&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; doc.LastChild().SetName(<span class="stringliteral">&quot;2&quot;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLModifyingAttributeData"></a>
Setting Attribute Data</h2>
<p>All attributes have name and value, both of which are strings (value may be empty). You can set them with the following functions: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ad5794d98983cbccd1db52b5ae77df412">Mezzanine::XML::Attribute::SetName</a>(<span class="keyword">const</span> char_t* rhs);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">Mezzanine::XML::Attribute::SetValue</a>(<span class="keyword">const</span> char_t* rhs);</div>
</div><!-- fragment --><p> Both functions try to set the name/value to the specified string, and return the operation result. The operation fails if the attribute handle is null, or if there is insufficient memory to handle the request. The provided string is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass stack-allocated buffers to these functions). The name/value content is not verified, so take care to use only valid XML names, or the document may become malformed. <br />
 <br />
 In addition to string functions, several functions are provided for handling attributes with numbers and booleans as values: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">Mezzanine::XML::Attribute::SetValue</a>(<span class="keywordtype">int</span> rhs);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">Mezzanine::XML::Attribute::SetValue</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rhs);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">Mezzanine::XML::Attribute::SetValue</a>(<span class="keywordtype">double</span> rhs);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">Mezzanine::XML::Attribute::SetValue</a>(<span class="keywordtype">bool</span> rhs);</div>
</div><!-- fragment --><p> The above functions convert the argument to string and then call the base SetValue function. Integers are converted to a decimal form, floating-point numbers are converted to either decimal or scientific form, depending on the number magnitude, boolean values are converted to either "true" or "false". </p><dl class="section warning"><dt>Warning</dt><dd>Number conversion functions depend on current C locale as set with setlocale, so may generate unexpected results if the locale is different from "C".</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are no portable 64-bit types in C++, so there is no corresponding SetValue function. If your platform has a 64-bit integer, you can easily write such a function yourself.</dd></dl>
<p>For convenience, all set_value functions have the corresponding assignment operators: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a5165c93882dde00373bac6c542bec6e2">Mezzanine::XML::Attribute::operator=</a>(<span class="keyword">const</span> char_t* rhs);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a5165c93882dde00373bac6c542bec6e2">Mezzanine::XML::Attribute::operator=</a>(<span class="keywordtype">int</span> rhs);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a5165c93882dde00373bac6c542bec6e2">Mezzanine::XML::Attribute::operator=</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rhs);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a5165c93882dde00373bac6c542bec6e2">Mezzanine::XML::Attribute::operator=</a>(<span class="keywordtype">double</span> rhs);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#a5165c93882dde00373bac6c542bec6e2">Mezzanine::XML::Attribute::operator=</a>(<span class="keywordtype">bool</span> rhs);</div>
</div><!-- fragment --><p> These operators simply call the right SetValue function and return the attribute they're called on; the return value of SetValue is ignored, so errors are ignored. <br />
 <br />
 This is an example of setting attribute name and value: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> attr = node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;id&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// change attribute name/value</span></div>
<div class="line">std::cout &lt;&lt; attr.<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ad5794d98983cbccd1db52b5ae77df412">SetName</a>(<span class="stringliteral">&quot;key&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; attr.<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">SetValue</a>(<span class="stringliteral">&quot;345&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;, new attribute: &quot;</span> &lt;&lt; attr.name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; attr.value() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// we can use numbers or booleans</span></div>
<div class="line">attr.<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#afff322c3640040f0054c6d1e346891fc">SetValue</a>(1.234);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;new attribute value: &quot;</span> &lt;&lt; attr.<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ac6e2e9cec855a3a69832b75c53f2de18">Value</a>() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// we can also use assignment operators for more concise code</span></div>
<div class="line">attr = <span class="keyword">true</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;final attribute value: &quot;</span> &lt;&lt; attr.value() &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLModifyingAdding"></a>
Adding Nodes/Attributes</h2>
<p>Nodes and attributes do not exist without a document tree, so you can't create them without adding them to some document. A node or attribute can be created at the end of node/attribute list or before/after some other node: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a20ea63a61ca1a7df2e00e074178bd9a4">Mezzanine::XML::Node::AppendAttribute</a>(<span class="keyword">const</span> char_t* Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a20ea63a61ca1a7df2e00e074178bd9a4">Mezzanine::XML::Node::AppendAttribute</a>(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&amp; Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a700646d6a97d8361cbf73653fcaf3212">Mezzanine::XML::Node::PrependAttribute</a>(<span class="keyword">const</span> char_t* Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#ac5c349d37f551a26522a357378f7cbd5">Mezzanine::XML::Node::InsertAttributeAfter</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; attr);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#acc20a1161f0a398b39605d63a41a0b3a">Mezzanine::XML::Node::InsertAttributeBefore</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; attr);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a65772e1f13ac21655e3ffbe8ffe4aaa1">Mezzanine::XML::Node::AppendChild</a>(<a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">Mezzanine::XML::NodeType</a> type = <a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564aa0460269885b6d435d76d62374780232c">NodeElement</a>);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a2c6b463b195439bcf3cbdd80e4f271c0">Mezzanine::XML::Node::PrependChild</a>(<a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">Mezzanine::XML::NodeType</a> type = <a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564aa0460269885b6d435d76d62374780232c">NodeElement</a>);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7963271c2ad283a37cbb750370daf4c9">Mezzanine::XML::Node::InsertChildAfter</a>(<a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">Mezzanine::XML::NodeType</a> type, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3d880d9761fa75e9582f22355693a1f6">Mezzanine::XML::Node::InsertChildBefore</a>(<a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">Mezzanine::XML::NodeType</a> type, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a65772e1f13ac21655e3ffbe8ffe4aaa1">Mezzanine::XML::Node::AppendChild</a>(<span class="keyword">const</span> char_t* Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a65772e1f13ac21655e3ffbe8ffe4aaa1">Mezzanine::XML::Node::AppendChild</a>(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&amp; Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a2c6b463b195439bcf3cbdd80e4f271c0">Mezzanine::XML::Node::PrependChild</a>(<span class="keyword">const</span> char_t* Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a2c6b463b195439bcf3cbdd80e4f271c0">Mezzanine::XML::Node::PrependChild</a>(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&amp; Name);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7963271c2ad283a37cbb750370daf4c9">Mezzanine::XML::Node::InsertChildAfter</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3d880d9761fa75e9582f22355693a1f6">Mezzanine::XML::Node::InsertChildBefore</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node);</div>
</div><!-- fragment --><p> AppendAttribute and AppendChild create a new node/attribute at the end of the corresponding list of the node the method is called on; PrependAttribute and PrependChild create a new node/attribute at the beginning of the list; InsertAttributeAfter, InsertAttributeBefore, InsertChildAfter and InsertAttributeBefore add the node/attribute before or after the specified node/attribute. <br />
 <br />
 The overloads of AppendChild and PrependChild that accept <a class="el" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">Mezzanine::String</a> references convert it to a string, then call the version of the function that accepts a c-style string. <br />
 <br />
 Attribute functions create an attribute with the specified name; you can specify the empty name and change the name later if you want to. Node functions with the type argument create the node with the specified type; since node type can't be changed, you have to know the desired type beforehand. Also note that not all types can be added as children; see below for clarification. Node functions with the name argument create the element node (NodeElement) with the specified name. <br />
 <br />
 All functions return the handle to the created object on success, and null handle on failure. There are several reasons for failure:</p><ul>
<li>Adding fails if the target node is null;</li>
<li>Only <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeElement</a> nodes can contain attributes, so attribute adding fails if node is not an element;</li>
<li>Only <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocument</a> and <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeElement</a> nodes can contain children, so child node adding fails if the target node is not an element or a document;</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocument</a> and <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeNull</a> nodes can not be inserted as children, so passing <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocument</a> or <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeNull value as type results in operation failure;</a></li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDeclaration</a> nodes can only be added as children of the document node; attempt to insert declaration node as a child of an element node fails;</li>
<li>Adding node/attribute results in memory allocation, which may fail;</li>
<li>Insertion functions fail if the specified node or attribute is null or is not in the target node's children/attribute list.</li>
</ul>
<p>Even if the operation fails, the document remains in consistent state, but the requested node/attribute is not added. </p><dl class="section warning"><dt>Warning</dt><dd>GetAttribute() and GetChild() functions do not add attributes or nodes to the tree, so code like node.GetAttribute("id") = 123; will not do anything if node does not have an attribute with name "id". Make sure you're operating with existing attributes/nodes by adding them if necessary.</dd></dl>
<p>This is an example of adding new attributes/nodes to the document: </p><div class="fragment"><div class="line"><span class="comment">// add node with some name</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> node = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a65772e1f13ac21655e3ffbe8ffe4aaa1">AppendChild</a>(<span class="stringliteral">&quot;node&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// add description node with text child</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> descr = node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a65772e1f13ac21655e3ffbe8ffe4aaa1">AppendChild</a>(<span class="stringliteral">&quot;description&quot;</span>);</div>
<div class="line">descr.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a65772e1f13ac21655e3ffbe8ffe4aaa1">AppendChild</a>(<a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564aa5611c39a6ed312b0aedb55ee4f1aaf78">Mezzanine::XML::NodePcdata</a>).<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa8bad1055873931e97cd12b044e838b4">SetValue</a>(<span class="stringliteral">&quot;Simple node&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// add param node before the description</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> param = node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3d880d9761fa75e9582f22355693a1f6">InsertChildBefore</a>(<span class="stringliteral">&quot;param&quot;</span>, descr);</div>
<div class="line"></div>
<div class="line"><span class="comment">// add attributes to param node</span></div>
<div class="line">param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a20ea63a61ca1a7df2e00e074178bd9a4">AppendAttribute</a>(<span class="stringliteral">&quot;name&quot;</span>) = <span class="stringliteral">&quot;version&quot;</span>;</div>
<div class="line">param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a20ea63a61ca1a7df2e00e074178bd9a4">AppendAttribute</a>(<span class="stringliteral">&quot;value&quot;</span>) = 1.1;</div>
<div class="line">param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#ac5c349d37f551a26522a357378f7cbd5">InsertAttributeAfter</a>(<span class="stringliteral">&quot;type&quot;</span>, param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;name&quot;</span>)) = <span class="stringliteral">&quot;float&quot;</span>;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLModifyingRemoving"></a>
Removing Nodes/Attributes</h2>
<p>If you do not want your document to contain some node or attribute, you can remove it with one of the following functions: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#abfa54ac3a7e75081fceee879f5d6a573">Mezzanine::XML::Node::RemoveAttribute</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; a);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7fb291fef7d56df2d6e0e0fc9a28e78b">Mezzanine::XML::Node::RemoveChild</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; n);</div>
</div><!-- fragment --><p> RemoveAttribute removes the attribute from the attribute list of the node, and returns the operation result. RemoveChild removes the child node with the entire subtree (including all descendant nodes and attributes) from the document, and returns the operation result. Removing fails if one of the following is true:</p><ul>
<li>The node the function is called on is null;</li>
<li>The attribute/node to be removed is null;</li>
<li>The attribute/node to be removed is not in the node's attribute/child list.</li>
</ul>
<p>Removing the attribute or node invalidates all handles to the same underlying object, and also invalidates all iterators pointing to the same object. Removing node also invalidates all past-the-end iterators to its attribute or child node list. Be careful to ensure that all such handles and iterators either do not exist or are not used after the attribute/node is removed. <br />
 <br />
 If you want to remove the attribute or child node by its name, two additional helper functions are available: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#abfa54ac3a7e75081fceee879f5d6a573">Mezzanine::XML::Node::RemoveAttribute</a>(<span class="keyword">const</span> char_t* Name);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7fb291fef7d56df2d6e0e0fc9a28e78b">Mezzanine::XML::Node::RemoveChild</a>(<span class="keyword">const</span> char_t* Name);</div>
</div><!-- fragment --><p> These functions look for the first attribute or child with the specified name, and then remove it, returning the result. If there is no attribute or child with such name, the function returns false; if there are two nodes with the given name, only the first node is deleted. If you want to delete all nodes with the specified name, you can use code like this: while (node.RemoveChild("tool")) ;. <br />
 <br />
 This is an example of removing attributes/nodes from the document: </p><div class="fragment"><div class="line"><span class="comment">// remove description node with the whole subtree</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> node = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;node&quot;</span>);</div>
<div class="line">node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7fb291fef7d56df2d6e0e0fc9a28e78b">RemoveChild</a>(<span class="stringliteral">&quot;description&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// remove id attribute</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> param = node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;param&quot;</span>);</div>
<div class="line">param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#abfa54ac3a7e75081fceee879f5d6a573">RemoveAttribute</a>(<span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// we can also remove nodes/attributes by handles</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <span class="keywordtype">id</span> = param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">param.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#abfa54ac3a7e75081fceee879f5d6a573">RemoveAttribute</a>(<span class="keywordtype">id</span>);</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLModifyingCloning"></a>
Cloning Nodes/Attributes</h2>
<p>With the help of previously described functions, it is possible to create trees with any contents and structure, including cloning the existing data. However since this is an often needed operation, Mezzanine::xml provides built-in node/attribute cloning facilities. Since nodes and attributes do not exist without a document tree, you can't create a standalone copy</p><ul>
<li>you have to immediately insert it somewhere in the tree. For this, you can use one of the following functions: <div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a6aff8fe6b9a3458e34932c86d5b832fd">Mezzanine::XML::Node::AppendCopy</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; proto);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3204a256181933deef123dcac4a549ea">Mezzanine::XML::Node::PrependCopy</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; proto);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8730a6fa8ef0368db283aac132822626">Mezzanine::XML::Node::InsertCopyAfter</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; attr);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8730a6fa8ef0368db283aac132822626">Mezzanine::XML::Node::InsertCopyAfter</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a>&amp; attr);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a6aff8fe6b9a3458e34932c86d5b832fd">Mezzanine::XML::Node::AppendCopy</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; proto);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3204a256181933deef123dcac4a549ea">Mezzanine::XML::Node::PrependCopy</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; proto);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8730a6fa8ef0368db283aac132822626">Mezzanine::XML::Node::InsertCopyAfter</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8730a6fa8ef0368db283aac132822626">Mezzanine::XML::Node::InsertCopyAfter</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a>&amp; node);</div>
</div><!-- fragment --></li>
</ul>
<p>These functions mirror the structure of AppendChild, PrependChild, InsertChildBefore and related functions - they take the handle to the prototype object, which is to be cloned, insert a new attribute/node at the appropriate place, and then copy the attribute data or the whole node subtree to the new object. The functions return the handle to the resulting duplicate object, or null handle on failure. <br />
 <br />
 The attribute is copied along with the name and value; the node is copied along with its type, name and value; additionally attribute list and all children are recursively cloned, resulting in the deep subtree clone. The prototype object can be a part of the same document, or a part of any other document. <br />
 <br />
 The failure conditions resemble those of AppendChild, InsertChild_before and related functions, consult their documentation for more information. There are additional caveats specific to cloning functions:</p><ul>
<li>Cloning null handles results in operation failure;</li>
<li>Node cloning starts with insertion of the node of the same type as that of the prototype; for this reason, cloning functions can not be directly used to clone entire documents, since <a class="el" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564a">NodeType::NodeDocument</a> is not a valid insertion type. The example below provides a workaround.</li>
<li>It is possible to copy a subtree as a child of some node inside this subtree, i.e. node.AppendCopy(node.GetParent().GetParent());. This is a valid operation, and it results in a clone of the subtree in the state before cloning started, i.e. no infinite recursion takes place.</li>
</ul>
<p>This is an example with one possible implementation of include tags in XML. It illustrates node cloning and usage of other document modification functions: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> LoadPreprocess(<a class="code" href="classMezzanine_1_1XML_1_1Document.html">Mezzanine::XML::Document</a>&amp; doc, <span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PreProcess(<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> node)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> child = node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a4fd3f099201e3e6001bdf2afea598a8a">GetFirstChild</a>(); child; )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (child.Type() == <a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564aaa3c062de3c4857d39596ee2e61d85427">Mezzanine::XML::NodePi</a> &amp;&amp; strcmp(child.Name(), <span class="stringliteral">&quot;include&quot;</span>) == 0)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> include = child;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// load new preprocessed document (note: ideally this should handle relative paths)</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span>* path = include.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8a7b598d8cfe9ceed1e23ec6832d6685">Value</a>();</div>
<div class="line"></div>
<div class="line">            <a class="code" href="classMezzanine_1_1XML_1_1Document.html">Mezzanine::XML::Document</a> doc;</div>
<div class="line">            <span class="keywordflow">if</span> (!LoadPreprocess(doc, path)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// insert the comment marker above include directive</span></div>
<div class="line">            node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a3d880d9761fa75e9582f22355693a1f6">InsertChildBefore</a>(<a class="code" href="namespaceMezzanine_1_1XML.html#a79dc84831ed2506631fb4adeb899564aad49fcbae52d40cca7aecbb34a90ba76f">pugi::NodeComment</a>, include).<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa8bad1055873931e97cd12b044e838b4">SetValue</a>(path);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// copy the document above the include directive (this retains the original order!)</span></div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> ic = doc.FirstChild(); ic; ic = ic.NextSibling())</div>
<div class="line">            {</div>
<div class="line">                node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a8730a6fa8ef0368db283aac132822626">InsertCopyAfter</a>(ic, include);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// remove the include node and move to the next child</span></div>
<div class="line">            child = child.NextSibling();</div>
<div class="line"></div>
<div class="line">            node.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7fb291fef7d56df2d6e0e0fc9a28e78b">RemoveChild</a>(include);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!PreProcess(child)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">            child = child.NextSibling();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> LoadPreprocess(<a class="code" href="classMezzanine_1_1XML_1_1Document.html">Mezzanine::XML::Document</a>&amp; doc, <span class="keyword">const</span> <span class="keywordtype">char</span>* path)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structMezzanine_1_1XML_1_1ParseResult.html">Mezzanine::XML::ParseResult</a> result = doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a89365dd7aa1cd2e25ebd72ceae8cad90">LoadFile</a>(path, <a class="code" href="namespaceMezzanine_1_1XML.html#a01d29dc9a004027ae57e863313c23c21">Mezzanine::XML::ParseDefault</a> | <a class="code" href="namespaceMezzanine_1_1XML.html#a10dfe21f7a8edcd95c34de367b723a1e">Mezzanine::XML::ParsePi</a>); <span class="comment">// for &lt;?include?&gt;</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> result ? PreProcess(doc) : false;</div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="XMLSaving"></a>
Saving Documents</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLSavingFile">Saving Documents to Files</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingStreams">Saving Documents to C++ IOstreams</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingWriter">Saving Document via Writer Interface</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingSubtree">Saving a Single Subtree</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingOptions">Output Options</a></li>
<li><a class="el" href="XMLManual.html#XMLSavingEncodings">Encodings</a></li>
</ul>
<p>Often after creating a new document or loading the existing one and processing it, it is necessary to save the result back to file. Also it is occasionally useful to output the whole document or a subtree to some stream; use cases include debug printing, serialization via network or other text-oriented medium, etc. Mezzanine::xml provides several functions to output any subtree of the document to a file, stream or another generic transport interface; these functions allow one to customize the output format ( see <a class="el" href="XMLManual.html#XMLSavingOptions">Output Options</a> ), and also perform necessary encoding conversions ( see <a class="el" href="XMLManual.html#XMLSavingEncodings">Encodings</a> ). This section documents the relevant functionality. <br />
 <br />
 Before writing to the destination the node/attribute data is properly formatted according to the node type; all special XML symbols, such as &lt; and &amp;, are properly escaped. In order to guard against forgotten node/attribute names, empty node/attribute names are printed as ":anonymous". For well-formed output, make sure all node and attribute names are set to meaningful values. <br />
 <br />
 CDATA sections with values that contain "]]&gt;" are split into several sections as follows: section with value "pre]]&gt;post" is written as &lt;![CDATA[pre]]]]&gt;&lt;![CDATA[&gt;post]]&gt;. While this alters the structure of the document (if you load the document after saving it, there will be two CDATA sections instead of one), this is the only way to escape CDATA contents. </p>
<h2><a class="anchor" id="XMLSavingFile"></a>
Saving Documents to Files</h2>
<p>If you want to save the whole document to a file, you can use one of the following functions: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a42feffdea66cc25d48fbc81eff21268e">Mezzanine::XML::Document::SaveFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* Path, <span class="keyword">const</span> Mezzanine::XML::char_t* indent = <span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags = <a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">Mezzanine::XML::FormatDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Mezzanine::XML::Encoding</a> encoding = <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#a42feffdea66cc25d48fbc81eff21268e">Mezzanine::XML::Document::SaveFile</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* Path, <span class="keyword">const</span> Mezzanine::XML::char_t* indent = <span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags = <a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">Mezzanine::XML::FormatDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Mezzanine::XML::Encoding</a> encoding = <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> These functions accept file path as its first argument, and also three optional arguments, which specify indentation and other output options (see Output options) and output data encoding ( see @ ref XMLSavingEncodings ). The Path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of the target system, it should have the exact case if the target file system is case-sensitive, etc. <br />
 <br />
 File path is passed to the system file opening function as is in case of the first function (which accepts const char* Path); the second function either uses a special file opening function if it is provided by the runtime library or converts the path to UTF-8 and uses the system file opening function. <br />
 <br />
 SaveFile opens the target file for writing, outputs the requested header (by default a document declaration is output, unless the document already has one), and then saves the document contents. If the file could not be opened, the function returns false. Calling SaveFile is equivalent to creating an <a class="el" href="classMezzanine_1_1XML_1_1WriterFile.html" title="An implementation of Writer intended for writing to FILEs as defined in stdio. ">Mezzanine::XML::WriterFile</a> object with FILE* handle as the only constructor argument and then calling save; see <a class="el" href="XMLManual.html#XMLSavingWriter">Saving Document via Writer Interface</a> for writer interface details. <br />
 <br />
 This is a simple example of saving XML document to a file : </p><div class="fragment"><div class="line"><span class="comment">// save document to file</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Saving result: &quot;</span> &lt;&lt; doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a42feffdea66cc25d48fbc81eff21268e">SaveFile</a>(<span class="stringliteral">&quot;save_file_output.xml&quot;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLSavingStreams"></a>
Saving Documents to C++ IOstreams</h2>
<p>To enhance interoperability Mezzanine::xml provides functions for saving document to any object which implements C++ std::ostream interface. This allows you to save documents to any standard C++ stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). Most notably, this allows for easy debug output, since you can use std::cout stream as saving target. There are two functions, one works with narrow character streams, another handles wide character ones: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#aebf22bbc54f2e69bcf19c7f2f9978ade">Mezzanine::XML::Document::Save</a>(std::ostream&amp; stream, <span class="keyword">const</span> char_t* indent = <span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags = <a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">Mezzanine::XML::FormatDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Mezzanine::XML::Encoding</a> encoding = <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#aebf22bbc54f2e69bcf19c7f2f9978ade">Mezzanine::XML::Document::Save</a>(std::wostream&amp; stream, <span class="keyword">const</span> char_t* indent = <span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags = <a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">Mezzanine::XML::FormatDefault</a>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Calling Save with an std::ostream argument saves the document to the stream in the same way as SaveFile (i.e. with requested header and with encoding conversions). On the other hand, save with std::wstream argument saves the document to the wide stream with <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding::Encodingwchar_t</a> encoding. Because of this, using save with wide character streams requires careful (usually platform-specific) stream setup (i.e. using the imbue function). Generally use of wide streams is discouraged, however it provides you with the ability to save documents to non-Unicode encodings, i.e. you can save Shift-JIS encoded data if you set the correct locale. <br />
 <br />
 Calling Save with stream target is equivalent to creating an <a class="el" href="classMezzanine_1_1XML_1_1WriterStream.html" title="An implementation of Writer intended for writing std::ostreams. ">Mezzanine::XML::WriterStream</a> object with stream as the only constructor argument and then calling save; see <a class="el" href="XMLManual.html#XMLSavingWriter">Saving Document via Writer Interface</a> for writer interface details. <br />
 <br />
 This is a simple example of saving XML document to standard output: </p><div class="fragment"><div class="line"><span class="comment">// save document to standard output</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Document:\n&quot;</span>;</div>
<div class="line">doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#aebf22bbc54f2e69bcf19c7f2f9978ade">Save</a>(std::cout);</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLSavingWriter"></a>
Saving Document via Writer Interface</h2>
<p>All of the above saving functions are implemented in terms of the <a class="el" href="classMezzanine_1_1XML_1_1Writer.html" title="Interface for node printing (see Node::Print) ">Mezzanine::XML::Writer</a> interface. This is a simple interface with a single function, which is called several times during output process with chunks of document data as input. </p><div class="fragment"><div class="line"><span class="keyword">class </span>Writer</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Write(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> size) = 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1XML_1_1Document.html#aebf22bbc54f2e69bcf19c7f2f9978ade">Mezzanine::XML::Document::Save</a> (Writer &amp;WriterInstance, <span class="keyword">const</span> char_t *indent=<span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags=<a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">FormatDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> In order to output the document via some custom transport, for example sockets, you should create an object which implements <a class="el" href="classMezzanine_1_1XML_1_1Writer.html" title="Interface for node printing (see Node::Print) ">Mezzanine::XML::Writer</a> interface and pass it to save function. <a class="el" href="classMezzanine_1_1XML_1_1Writer.html#af66d88be522819819cf552ff237a905e" title="Write memory chunk into stream/file/whatever. ">Mezzanine::XML::Writer::Write</a> function is called with a buffer as an input, where data points to buffer start, and size is equal to the buffer size in bytes. The Write implementation must write the buffer to the transport; it can not save the passed buffer pointer, as the buffer contents will change after write returns. The buffer contains the chunk of document data in the desired encoding. <br />
 <br />
 The Write function is called with relatively large blocks (size is usually several kilobytes, except for the first block with BOM, which is output only if <a class="el" href="namespaceMezzanine_1_1XML.html#a38a1aa387d54f0386ed79a0b04bee1e4" title="Write encoding-specific Byte Order Mark (BOM) to the output stream. This flag is off by default...">Mezzanine::XML::FormatWriteBom</a> is set, and last block, which may be small), so there is often no need for additional buffering in the implementation. <br />
 <br />
 This is a simple example of custom writer for saving document data to STL string: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>StringWriter: <a class="code" href="classMezzanine_1_1XML_1_1Writer.html">Mezzanine::XML::Writer</a></div>
<div class="line">{</div>
<div class="line">    std::string Result;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1XML_1_1Writer.html#af66d88be522819819cf552ff237a905e">Write</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        Result += std::string(static_cast&lt;const char*&gt;(data), size);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLSavingSubtree"></a>
Saving a Single Subtree</h2>
<p>While the previously described functions save the whole document to the destination, it is easy to save a single subtree. The following functions are provided: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aef52a586c2e21dce71397f3400c61b72">Mezzanine::XML::Node::Print</a>(std::basic_ostream&lt; <span class="keywordtype">char</span>, std::char_traits&lt; char &gt; &gt; &amp;os, <span class="keyword">const</span> char_t *indent=<span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags=<a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">FormatDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mezztest_8cpp.html#a3ec8bc0304fdae6d46846f2796c5a312">Depth</a>=0) <span class="keyword">const</span> ;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aef52a586c2e21dce71397f3400c61b72">Mezzanine::XML::Node::Print</a>(std::basic_ostream&lt; <span class="keywordtype">wchar_t</span>, std::char_traits&lt; wchar_t &gt; &gt; &amp;os, <span class="keyword">const</span> char_t *indent=<span class="stringliteral">&quot;\t&quot;</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags=<a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">FormatDefault</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mezztest_8cpp.html#a3ec8bc0304fdae6d46846f2796c5a312">Depth</a>=0) const ) const;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMezzanine.html">Mezzanine</a>::XML::Node::Print(<a class="code" href="namespaceMezzanine.html">Mezzanine</a>::XML::Writer &amp;WriterInstance, const char_t *indent=&quot;\t&quot;, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags=<a class="code" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc">FormatDefault</a>, <a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encoding</a> DocumentEncoding=<a class="code" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057aae3f2f76c60cf95820362667965d1990">EncodingAuto</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mezztest_8cpp.html#a3ec8bc0304fdae6d46846f2796c5a312">Depth</a>=0) const;</div>
</div><!-- fragment --><p> These functions have the same arguments with the same meaning as the corresponding <a class="el" href="classMezzanine_1_1XML_1_1Document.html#aebf22bbc54f2e69bcf19c7f2f9978ade" title="Save XML document to WriterInstance. ">Mezzanine::XML::Document::Save</a> functions, and allow you to save the subtree to either a C++ IOstream or to any object that implements <a class="el" href="classMezzanine_1_1XML_1_1Writer.html" title="Interface for node printing (see Node::Print) ">Mezzanine::XML::Writer</a> interface. <br />
 <br />
 Saving a subtree differs from saving the whole document: the process behaves as if <a class="el" href="namespaceMezzanine_1_1XML.html#a38a1aa387d54f0386ed79a0b04bee1e4" title="Write encoding-specific Byte Order Mark (BOM) to the output stream. This flag is off by default...">Mezzanine::XML::FormatWriteBom</a> is off, and <a class="el" href="namespaceMezzanine_1_1XML.html#a965e10fd6db7e52461671ce5a05da1e6" title="Omit default XML declaration even if there is no declaration in the document. This flag is off by def...">Mezzanine::XML::FormatNoDeclaration</a> is on, even if actual values of the flags are different. This means that BOM is not written to the destination, and document declaration is only written if it is the node itself or is one of node's children. Note that this also holds if you're saving a document; this example illustrates the difference: </p><div class="fragment"><div class="line"><span class="comment">// get a test document</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Document.html">Mezzanine::XML::Document</a> doc;</div>
<div class="line">doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#a319fa46ad3580c3643bb1678e51c1721">Load</a>(<span class="stringliteral">&quot;&lt;foo bar=&#39;baz&#39;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// print document to standard output (prints &lt;?xml version=&quot;1.0&quot;?&gt;&lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span></div>
<div class="line">doc.<a class="code" href="classMezzanine_1_1XML_1_1Document.html#aebf22bbc54f2e69bcf19c7f2f9978ade">Save</a>(std::cout, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="namespaceMezzanine_1_1XML.html#a113ddc3c498f17dde89bce5b7ceb5661">Mezzanine::XML::FormatRaw</a>);</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// print document to standard output as a regular node (prints &lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span></div>
<div class="line">doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aef52a586c2e21dce71397f3400c61b72">Print</a>(std::cout, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="namespaceMezzanine_1_1XML.html#a113ddc3c498f17dde89bce5b7ceb5661">Mezzanine::XML::FormatRaw</a>);</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// print a subtree to standard output (prints &lt;call&gt;hey&lt;/call&gt;)</span></div>
<div class="line">doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;foo&quot;</span>).<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a9c5b7b5376c9444d3d1d0bfeb47e4dc4">GetChild</a>(<span class="stringliteral">&quot;call&quot;</span>).<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aef52a586c2e21dce71397f3400c61b72">Print</a>(std::cout, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="namespaceMezzanine_1_1XML.html#a113ddc3c498f17dde89bce5b7ceb5661">Mezzanine::XML::FormatRaw</a>);</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLSavingOptions"></a>
Output Options</h2>
<p>All saving functions accept the optional parameter flags. This is a bitmask that customizes the output format; you can select the way the document nodes are printed and select the needed additional information that is output before the document contents. </p><dl class="section note"><dt>Note</dt><dd>You should use the usual bitwise arithmetics to manipulate the bitmask: to enable a flag, use mask | flag; to disable a flag, use mask &amp; ~flag.</dd></dl>
<p>These flags control the resulting tree contents:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a8c0eb20115e575906a663bc7fe5ba356" title="Indent the nodes that are written to output stream with as many indentation strings as deep the node ...">Mezzanine::XML::FormatIndent</a> determines if all nodes should be indented with the indentation string (this is an additional parameter for all saving functions, and is "\t" by - default). If this flag is on, before every node the indentation string is output several times, where the amount of indentation depends on the node's depth relative to the output subtree. This flag has no effect if <a class="el" href="namespaceMezzanine_1_1XML.html#a113ddc3c498f17dde89bce5b7ceb5661" title="Use raw output mode (no indentation and no line breaks are written). This flag is on by default...">Mezzanine::XML::FormatRaw</a> is enabled. This flag is off by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a113ddc3c498f17dde89bce5b7ceb5661" title="Use raw output mode (no indentation and no line breaks are written). This flag is on by default...">Mezzanine::XML::FormatRaw</a> switches between formatted and raw output. If this flag is on, the nodes are not indented in any way, and also no newlines that are not part of document text are printed. Raw mode can be used for serialization where the result is not intended to be read by humans; also it can be useful if the document was parsed with <a class="el" href="namespaceMezzanine_1_1XML.html#ad154251a7def4608431a84fdeef8e8d6" title="This flag determines if plain character data (NodePcdata) that consist only of whitespace are added t...">Mezzanine::XML::ParseWsPcdata</a> flag, to preserve the original document formatting as much as possible. This flag is on by default.</li>
</ul>
<p>These flags control the additional output information:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a965e10fd6db7e52461671ce5a05da1e6" title="Omit default XML declaration even if there is no declaration in the document. This flag is off by def...">Mezzanine::XML::FormatNoDeclaration</a> disables default node declaration output. By default, if the document is saved via save or SaveFile function, and it does not have any document declaration, a default declaration is output before the document contents. Enabling this flag disables this declaration. This flag has no effect in <a class="el" href="classMezzanine_1_1XML_1_1Node.html#aef52a586c2e21dce71397f3400c61b72" title="Output the XML document using a Writer. ">Mezzanine::XML::Node::Print</a> functions: they never output the default declaration. This flag is off by default.</li>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a38a1aa387d54f0386ed79a0b04bee1e4" title="Write encoding-specific Byte Order Mark (BOM) to the output stream. This flag is off by default...">Mezzanine::XML::FormatWriteBom</a> enables Byte Order Mark (BOM) output. By default, no BOM is output, so in case of non UTF-8 encodings the resulting document's encoding may not be recognized by some parsers and text editors, if they do not implement sophisticated encoding detection. Enabling this flag adds an encoding-specific BOM to the output. This flag has no effect in <a class="el" href="classMezzanine_1_1XML_1_1Node.html#aef52a586c2e21dce71397f3400c61b72" title="Output the XML document using a Writer. ">Mezzanine::XML::Node::Print</a> functions: they never output the BOM. This flag is off by default.</li>
</ul>
<p>Additionally, there is one predefined option mask:</p><ul>
<li><a class="el" href="namespaceMezzanine_1_1XML.html#a9a9b9245ea32348c78817d002ecd61fc" title="The default set of formatting flags. Only FormatRaw is enabled. ">Mezzanine::XML::FormatDefault</a> is the default set of flags, i.e. it has all options set to their default values. This differs from the default pugixml settings and only sets <a class="el" href="namespaceMezzanine_1_1XML.html#a113ddc3c498f17dde89bce5b7ceb5661" title="Use raw output mode (no indentation and no line breaks are written). This flag is on by default...">Mezzanine::XML::FormatRaw</a> . This is to minimize output size, and optimize for computer consumption of xml.</li>
</ul>
<h2><a class="anchor" id="XMLSavingEncodings"></a>
Encodings</h2>
<p>Mezzanine::xml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it's a strict subset of UTF-16) and handles all encoding conversions during output. The output encoding is set via the encoding parameter of saving functions, which is of type xml_encoding. The possible values for the encoding are documented in Encodings; the only flag that has a different meaning is EncodingAuto. <br />
 <br />
 While all other flags set the exact encoding, EncodingAuto is meant for automatic encoding detection. The automatic detection does not make sense for output encoding, since there is usually nothing to infer the actual encoding from, so here <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">EncodingAuto</a> means UTF-8 encoding, which is the most popular encoding for XML data storage. This is also the default value of output encoding; specify another value if you do not want UTF-8 encoded output. <br />
 <br />
 Also note that wide stream saving functions do not have encoding argument and always assume <a class="el" href="namespaceMezzanine_1_1XML.html#a77aa299731a2a63d9bab92cf6f03b057">Encodingwchar_t</a> encoding. </p><dl class="section note"><dt>Note</dt><dd>The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; if your node/attribute names do not contain any valid UTF sequences, they may be output as if they are empty, which will result in malformed XML document. </dd></dl>
<h1><a class="anchor" id="XMLXPath"></a>
XPath</h1>
<ul>
<li><a class="el" href="XMLManual.html#XMLXPathTypes">XPath Types</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathSelecting">Selecting Nodes via XPath Expression</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathQuery">Using Query Objects</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathVariables">Using Variables</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathError">Error Handling</a></li>
<li><a class="el" href="XMLManual.html#XMLXPathStandards">Conformance to W3C Specification</a></li>
</ul>
<p>If the task at hand is to select a subset of document nodes that match some criteria, it is possible to code a function using the existing traversal functionality for any practical criteria. However, often either a data-driven approach is desirable, in case the criteria are not predefined and come from a file, or it is inconvenient to use traversal interfaces and a higher-level Domain Specific Language is required. There is a standard language for XML processing, XPath, that can be useful for these cases. Mezzanine::xml implements an almost complete subset of XPath 1.0. Because of differences in document object model and some performance implications, there are minor violations of the official specifications, which can be found in <a class="el" href="XMLManual.html#XMLXPathStandards">Conformance to W3C Specification</a> . The rest of this section describes the interface for XPath functionality. Please note that if you wish to learn to use XPath language, you have to look for other tutorials or manuals. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLXPathTypes"></a>
XPath Types</h2>
<p>Each XPath expression can have one of the following types: boolean, number, string or node set. Boole type corresponds to bool type, number type corresponds to double type, string type corresponds to either std::string or std::wstring, depending on whether wide character interface is enabled, and node set corresponds to <a class="el" href="classMezzanine_1_1XML_1_1XPathNodeSet.html" title="A fixed sized collection of nodes that an XPathQuery can work on. ">Mezzanine::XML::XPathNodeSet</a> type. There is an enumeration, <a class="el" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee" title="XPathQuery return type. ">Mezzanine::XML::XPathValueType</a>, which can take the values <a class="el" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">XPathTypeBoole</a>, <a class="el" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">XPathTypeNumber</a>, <a class="el" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">Mezzanine::XML::XPathValueType</a> XPathTypeString or <a class="el" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">Mezzanine::XML::XPathValueType</a> XPathTypeNodeSet, accordingly. <br />
 <br />
 Because an XPath node can be either a node or an attribute, there is a special type, <a class="el" href="classMezzanine_1_1XML_1_1XPathNode.html" title="An XPath node which can store handles to a XML::Node or an XML::Attribute. ">Mezzanine::XML::XPathNode</a>, which is a discriminated union of these types. A value of this type contains two node handles, one of <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> type, and another one of <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> type; at most one of them can be non-null. The accessors to get these handles are available: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html#a39ef5315531ab1b41ad32a65aee8d789">Mezzanine::XML::XPathNode::GetNode</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Attribute.html">Mezzanine::XML::Attribute</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html#a0e97308e20646bffcaf2b643a4900ce4">Mezzanine::XML::XPathNode::GetAttribute</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> XPath nodes can be null, in which case both accessors return null handles. <br />
 <br />
 Note that as per XPath specification, each XPath node has a parent, which can be retrieved via this function: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html#a0c7360b3dd160826fdd26f33ec29db15">Mezzanine::XML::XPathNode::GetParent</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The GetParent function returns the node's parent if the XPath node corresponds to <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> handle (equivalent to GetNode().GetParent()), or the node to which the attribute belongs to, if the XPath node corresponds to <a class="el" href="classMezzanine_1_1XML_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree. ">Mezzanine::XML::Attribute</a> handle. For null nodes, parent returns null handle. <br />
 <br />
 Like node and attribute handles, XPath node handles can be implicitly cast to boolean-like object to check if it is a null node, and also can be compared for equality with each other. <br />
 <br />
 You can also create XPath nodes with one of the three constructors: the default constructor, the constructor that takes node argument, and the constructor that takes an attribute and a node argument (in which case the attribute must belong to the attribute list of the node). The constructor from <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> is implicit, so you can usually pass <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> to functions that expect <a class="el" href="classMezzanine_1_1XML_1_1XPathNode.html" title="An XPath node which can store handles to a XML::Node or an XML::Attribute. ">Mezzanine::XML::XPathNode</a>. Apart from that you usually don't need to create your own XPath node objects, since they are returned to you via selection functions. <br />
 <br />
 XPath expressions operate not on single nodes, but instead on node sets. A node set is a collection of nodes, which can be optionally ordered in either a forward document order or a reverse one. Document order is defined in XPath specification; an XPath node is before another node in document order if it appears before it in XML representation of the corresponding document. <br />
 <br />
 Node sets are represented by <a class="el" href="classMezzanine_1_1XML_1_1XPathNodeSet.html" title="A fixed sized collection of nodes that an XPathQuery can work on. ">Mezzanine::XML::XPathNodeSet</a> object, which has an interface that resembles one of sequential random-access containers. It has an iterator type along with usual begin/past-the-end iterator accessors: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>* <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a1d1b98b5eeb462da984550b919846cd5">Mezzanine::XML::XPathNodeSet::const_iterator</a>;</div>
<div class="line">const_iterator <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a6803f7eb73183f62b20ad679bf12c97b">Mezzanine::XML::XPathNodeSet::begin</a>() <span class="keyword">const</span>;</div>
<div class="line">const_iterator <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a6e85d1d1e087da91b0863705b2d26aaf">Mezzanine::XML::XPathNodeSet::end</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> And it also can be iterated via indices, just like std::vector: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a70f22b0560acd93fba225e8e8e861abc">Mezzanine::XML::XPathNodeSet::operator[]</a>(<span class="keywordtype">size_t</span> index) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">size_t</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a97a2e9baa3876ce43d70ffda92e051bc">Mezzanine::XML::XPathNodeSet::size</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> Mezzanine::XML::XPathNodeSet::empty() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> All of the above operations have the same semantics as that of std::vector: the iterators are random-access, all of the above operations are constant time, and accessing the element at index that is greater or equal than the set size results in undefined behavior. You can use both iterator-based and index-based access for iteration, however the iterator-based one can be faster. <br />
 <br />
 The order of iteration depends on the order of nodes inside the set; the order can be queried via the following function: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#ad184fcc38a7c200dda2b3836d3e0e424">Mezzanine::XML::XPathNodeSet::CollectionType</a> { TypeUnsorted, TypeSorted, TypeSortedReverse };</div>
<div class="line">CollectionType <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a9632844e3e7a17c29529a0b2c34f52fe">Mezzanine::XML::XPathNodeSet::Type</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The Type function returns the current order of nodes; TypeSorted means that the nodes are in forward document order, TypeSortedReverse means that the nodes are in reverse document order, and TypeUnsorted means that neither order is guaranteed (nodes can accidentally be in a sorted order even if Type() returns TypeUnsorted). If you require a specific order of iteration, you can change it via sort function: void <a class="el" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#ae2549590012152867250f689751f366e" title="Sort the collection in ascending/descending order by document order. ">Mezzanine::XML::XPathNodeSet::sort</a>(bool reverse = false); </p><dl class="section warning"><dt>Warning</dt><dd>When converted from the pugixml naming scheme, changes were made to this class conservatively. Once it is determine what the new names should be. this could be changed.</dd></dl>
<p>Calling sort sorts the nodes in either forward or reverse document order, depending on the argument; after this call Type() will return TypeSorted or TypeSortedReverse. <br />
 <br />
 Often the actual iteration is not needed; instead, only the first element in document order is required. For this, a special accessor is provided: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a51ef3a88c1cfd2c76834b84ae5d99b8f">Mezzanine::XML::XPathNodeSet::first</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> This function returns the first node in forward document order from the set, or null node if the set is empty. Note that while the result of the node does not depend on the order of nodes in the set (i.e. on the result of Type()), the complexity does - if the set is sorted, the complexity is constant, otherwise it is linear in the number of elements or worse. <br />
 <br />
 While in the majority of cases the node set is returned by XPath functions, sometimes there is a need to manually construct a node set. For such cases, a constructor is provided which takes an iterator range (const_iterator is a typedef for const <a class="el" href="classMezzanine_1_1XML_1_1XPathNode.html" title="An XPath node which can store handles to a XML::Node or an XML::Attribute. ">Mezzanine::XML::XPathNode</a>*), and an optional type: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a33b78eb97c4643f33580d42adb480a63">Mezzanine::XML::XPathNodeSet::XPathNodeSet</a>(const_iterator begin, const_iterator end, CollectionType Type=TypeUnsorted);</div>
</div><!-- fragment --><p> The constructor copies the specified range and sets the specified type. The objects in the range are not checked in any way; you'll have to ensure that the range contains no duplicates, and that the objects are sorted according to the type parameter. Otherwise XPath operations with this set may produce unexpected results. <br />
 <br />
</p>
<h2><a class="anchor" id="XMLXPathSelecting"></a>
Selecting Nodes via XPath Expression</h2>
<p>If you want to select nodes that match some XPath expression, you can do it with the following functions: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a1c6c47f340158d638354e181218da8cc">Mezzanine::XML::Node::FindSingleNode</a>(<span class="keyword">const</span> char_t* query, XPathVariableSet* variables = 0) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">Mezzanine::XML::Node::FindNodes</a>(<span class="keyword">const</span> char_t* query, XPathVariableSet* variables = 0) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The FindNodes function compiles the expression and then executes it with the node as a context node, and returns the resulting node set. FindSingleNode returns only the first node in document order from the result, and is equivalent to calling FindNodes(query).first(). If the XPath expression does not match anything, or the node handle is null, FindNodes returns an empty set, and FindSingleNode returns null XPath node. <br />
 <br />
 Both functions throw Mezzanine::XML::XPathException if the query can not be compiled or if it returns a value with type other than node set; see Error handling for details. <br />
 <br />
 While compiling expressions is fast, the compilation time can introduce a significant overhead if the same expression is used many times on small subtrees. If you're doing many similar queries, consider compiling them into query objects (see <a class="el" href="XMLManual.html#XMLXPathQuery">Using Query Objects</a> for further reference). Once you get a compiled query object, you can pass it to Find functions instead of an expression string: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#a1c6c47f340158d638354e181218da8cc">Mezzanine::XML::Node::FindSingleNode</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a>&amp; query) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> <a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">Mezzanine::XML::Node::FindNodes</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a>&amp; query) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Both functions throw Mezzanine::XML::XPathException if the query returns a value with type other than node set. <br />
 <br />
 This is an example of selecting nodes using XPath expressions: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> tools = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">FindNodes</a>(<span class="stringliteral">&quot;/Profile/Tools/Tool[@AllowRemote=&#39;true&#39; and @DeriveCaptionFrom=&#39;lastparam&#39;]&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Tools:&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (Mezzanine::XML::XPathNodeSet::const_iterator it = tools.<a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a6803f7eb73183f62b20ad679bf12c97b">begin</a>(); it != tools.<a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html#a6e85d1d1e087da91b0863705b2d26aaf">end</a>(); ++it)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a> node = *it;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; node.<a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html#a39ef5315531ab1b41ad32a65aee8d789">GetNode</a>().<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;Filename&quot;</span>).<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ac6e2e9cec855a3a69832b75c53f2de18">Value</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a> BuildTool = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a1c6c47f340158d638354e181218da8cc">FindSingleNode</a>(<span class="stringliteral">&quot;//Tool[contains(Description, &#39;build system&#39;)]&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;\nBuild tool: &quot;</span> &lt;&lt; BuildTool.<a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html#a39ef5315531ab1b41ad32a65aee8d789">GetNode</a>().<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a7257f2f9f8e08461260afae0d5062aa7">GetAttribute</a>(<span class="stringliteral">&quot;Filename&quot;</span>).<a class="code" href="classMezzanine_1_1XML_1_1Attribute.html#ac6e2e9cec855a3a69832b75c53f2de18">Value</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLXPathQuery"></a>
Using Query Objects</h2>
<p>When you call FindNodes with an expression string as an argument, a query object is created behind the scenes. A query object represents a compiled XPath expression. Query objects can be useful in the following circumstances:</p><ul>
<li>You can precompile expressions to query objects to save compilation time if it becomes an issue;</li>
<li>You can use query objects to evaluate XPath expressions which result in booleans, numbers or strings;</li>
<li>You can get the type of expression value via query object.</li>
</ul>
<p>Query objects correspond to <a class="el" href="classMezzanine_1_1XML_1_1XPathQuery.html" title="A compiled XPath query object. ">Mezzanine::XML::XPathQuery</a> type. They are immutable and non-copyable: they are bound to the expression at creation time and can not be cloned. If you want to put query objects in a container, allocate them on heap via new operator and store pointers to <a class="el" href="classMezzanine_1_1XML_1_1XPathQuery.html" title="A compiled XPath query object. ">Mezzanine::XML::XPathQuery</a> in the container. <br />
 <br />
 You can create a query object with the constructor that takes XPath expression as an argument: </p><div class="fragment"><div class="line"><span class="keyword">explicit</span> Mezzanine::XML::XPathQuery::XPathQuery(<span class="keyword">const</span> char_t* query, XPathVariableSet* variables = 0);</div>
</div><!-- fragment --><p> The expression is compiled and the compiled representation is stored in the new query object. If compilation fails, XPathException is thrown if exception handling is not disabled (see <a class="el" href="XMLManual.html#XMLXPathError">Error Handling</a> for details). After the query is created, you can query the type of the evaluation result using the following function: </p><div class="fragment"><div class="line"><a class="code" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">Mezzanine::XML::XPathValueType</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html#a46602c7c60a7e5a23e40fb5857904f67">Mezzanine::XML::XPathQuery::ReturnType</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> You can evaluate the query using one of the following functions: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html#a2396a82df0774dc15cf1f1c35329ad31">Mezzanine::XML::XPathQuery::EvaluateBoole</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>&amp; n) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html#a745a0a9f898c1a727bcdf05385b3e447">Mezzanine::XML::XPathQuery::EvaluateNumber</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>&amp; n) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86">Mezzanine::String</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html#ac565378e493693276a23ab59f1007c2c">Mezzanine::XML::XPathQuery::EvaluateString</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>&amp; n) <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html#a2a194972f7d30c092b05fc8a7e136313">Mezzanine::XML::XPathQuery::EvaluateNodeSet</a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>&amp; n) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> All functions take the context node as an argument, compute the expression and return the result, converted to the requested type. According to XPath specification, value of any type can be converted to boolean, number or string value, but no type other than node set can be converted to node set. Because of this, EvaluateBoole, EvaluateNumber and EvaluateString always return a result, but EvaluateNodeSet results in an error if the return type is not node set ( see <a class="el" href="XMLManual.html#XMLXPathError">Error Handling</a> ). </p><dl class="section note"><dt>Note</dt><dd>Calling node.FindNodes("query") is equivalent to calling <a class="el" href="classMezzanine_1_1XML_1_1XPathQuery.html" title="A compiled XPath query object. ">Mezzanine::XML::XPathQuery</a>("query").EvaluateNodeSet(node).</dd></dl>
<p>There is another string evaluation function: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html#ac565378e493693276a23ab59f1007c2c">Mezzanine::XML::XPathQuery::EvaluateString</a>(char_t* buffer, <span class="keywordtype">size_t</span> capacity, <span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a>&amp; n) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> This function evaluates the string, and then writes the result to buffer (but at most capacity characters); then it returns the full size of the result in characters, including the terminating zero. If capacity is not 0, the resulting buffer is always zero-terminated. You can use this function as follows:</p><ul>
<li>First call the function with buffer = 0 and capacity = 0; then allocate the returned amount of characters, and call the function again, passing the allocated storage and the amount of characters;</li>
<li>First call the function with small buffer and buffer capacity; then, if the result is larger than the capacity, the output has been trimmed, so allocate a larger buffer and call the function again.</li>
</ul>
<p>This is an example of using query objects: </p><div class="fragment"><div class="line"><span class="comment">// Select nodes via compiled query</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a> QueryRemoteTools(<span class="stringliteral">&quot;/Profile/Tools/Tool[@AllowRemote=&#39;true&#39;]&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> tools = QueryRemoteTools.EvaluateNodeSet(doc);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Remote tool: &quot;</span>;</div>
<div class="line">tools[2].node().print(std::cout);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Evaluate numbers via compiled query</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a> QueryTimeouts(<span class="stringliteral">&quot;sum(//Tool/@Timeout)&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; QueryTimeouts.EvaluateNumber(doc) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Evaluate strings via compiled query for different context nodes</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a> QueryNameValid(<span class="stringliteral">&quot;string-length(substring-before(@Filename, &#39;_&#39;)) &gt; 0 and @OutputFileMasks&quot;</span>);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a> QueryName(<span class="stringliteral">&quot;concat(substring-before(@Filename, &#39;_&#39;), &#39; produces &#39;, @OutputFileMasks)&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classMezzanine_1_1XML_1_1Node.html">Mezzanine::XML::Node</a> tool = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#a446781c040be454e12282ff91d28cb20">FirstElementByPath</a>(<span class="stringliteral">&quot;Profile/Tools/Tool&quot;</span>); tool; tool = tool.NextSibling())</div>
<div class="line">{</div>
<div class="line">    std::string s = QueryName.EvaluateString(tool);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (QueryNameValid.EvaluateBoole(tool)) std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLXPathVariables"></a>
Using Variables</h2>
<p>XPath queries may contain references to variables; this is useful if you want to use queries that depend on some dynamic parameter without manually preparing the complete query string, or if you want to reuse the same query object for similar queries. <br />
 <br />
 Variable references have the form $name; in order to use them, you have to provide a variable set, which includes all variables present in the query with correct types. This set is passed to <a class="el" href="classMezzanine_1_1XML_1_1XPathQuery.html" title="A compiled XPath query object. ">Mezzanine::XML::XPathQuery</a> constructor or to FindNodes/FindNode functions: </p><div class="fragment"><div class="line"><span class="keyword">explicit</span> Mezzanine::XML::XPathQuery::Mezzanine::XML::XPathQuery(<span class="keyword">const</span> char_t* query, XPathVariableSet* variables = 0);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNode.html">Mezzanine::XML::XPathNode</a> xml_node::FindNode(<span class="keyword">const</span> char_t* query, XPathVariableSet* variables = 0) <span class="keyword">const</span>;</div>
<div class="line">XPathNodeSet xml_node::FindNodes(<span class="keyword">const</span> char_t* query, XPathVariableSet* variables = 0) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> If you're using query objects, you can change the variable values before evaluate/select calls to change the query behavior. </p><dl class="section note"><dt>Note</dt><dd>The variable set pointer is stored in the query object; you have to ensure that the lifetime of the set exceeds that of query object.</dd></dl>
<p>Variable sets correspond to XPathVariableSet type, which is essentially a variable container. <br />
 <br />
 You can add new variables with the following function: </p><div class="fragment"><div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html">Mezzanine::XML::XPathVariable</a>* <a class="code" href="classMezzanine_1_1XML_1_1XPathVariableSet.html#a28e5de15a37877c8f416d08ba2ed6bf5">Mezzanine::XML::XPathVariableSet::Add</a>(<span class="keyword">const</span> char_t* Name, <a class="code" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">Mezzanine::XML::XPathValueType</a> type);</div>
</div><!-- fragment --><p> The function tries to add a new variable with the specified name and type; if the variable with such name does not exist in the set, the function adds a new variable and returns the variable handle; if there is already a variable with the specified name, the function returns the variable handle if variable has the specified type. Otherwise the function returns null pointer; it also returns null pointer on allocation failure. <br />
 <br />
 New variables are assigned the default value which depends on the type: 0 for numbers, false for booleans, empty string for strings and empty set for node sets. <br />
 <br />
 You can get the existing variables with the following functions: </p><div class="fragment"><div class="line">XPathVariable* XPathVariableSet::Get(<span class="keyword">const</span> char_t* Name);</div>
<div class="line"><span class="keyword">const</span> XPathVariable* XPathVariableSet::Get(<span class="keyword">const</span> char_t* Name) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The functions return the variable handle, or null pointer if the variable with the specified name is not found. <br />
 <br />
 Additionally, there are the helper functions for setting the variable value by name; they try to add the variable with the corresponding type, if it does not exist, and to set the value. If the variable with the same name but with different type is already present, they return false; they also return false on allocation failure. Note that these functions do not perform any type conversions. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> XPathVariableSet::Set(<span class="keyword">const</span> char_t* Name, <span class="keywordtype">bool</span> Value);</div>
<div class="line"><span class="keywordtype">bool</span> XPathVariableSet::Set(<span class="keyword">const</span> char_t* Name, <span class="keywordtype">double</span> Value);</div>
<div class="line"><span class="keywordtype">bool</span> XPathVariableSet::Set(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> char_t* Value);</div>
<div class="line"><span class="keywordtype">bool</span> XPathVariableSet::Set(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> XPathNodeSet&amp; Value);</div>
</div><!-- fragment --><p> The variable values are copied to the internal variable storage, so you can modify or destroy them after the functions return. <br />
 <br />
 If setting variables by name is not efficient enough, or if you have to inspect variable information or get variable values, you can use variable handles. A variable corresponds to the XPathVariable type, and a variable handle is simply a pointer to XPathVariable. <br />
 <br />
 In order to get variable information, you can use one of the following functions: </p><div class="fragment"><div class="line"><span class="keyword">const</span> char_t* <a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html#ab84ff6e6a66ff18583b134db9b6ab59d">Mezzanine::XML::XPathVariable::Name</a>() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77ee">Mezzanine::XML::XPathValueType</a> <a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html#aa3357c23f8441342e10738f47d3dd188">Mezzanine::XML::XPathVariable::Type</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Note that each variable has a distinct type which is specified upon variable creation and can not be changed later. <br />
 <br />
 In order to get variable value, you should use one of the following functions, depending on the variable type: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html#a4e6f42afb32797ba5f0bba72588ca8c8">Mezzanine::XML::XPathVariable::GetBoole</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html#a2ec85ddd845e082e4320df453967bbc2">Mezzanine::XML::XPathVariable::GetNumber</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">const</span> char_t* <a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html#ac2d53f8d952176ab958d0e7e9cbe6191">Mezzanine::XML::XPathVariable::GetString</a>() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a>&amp; <a class="code" href="classMezzanine_1_1XML_1_1XPathVariable.html#aa53b10b2981e4b39e65fd4b6c49a215b">Mezzanine::XML::XPathVariable::GetNodeSet</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> These functions return the value of the variable. Note that no type conversions are performed; if the type mismatch occurs, a dummy value is returned (false for booleans, NaN for numbers, empty string for strings and empty set for node sets). <br />
 <br />
 In order to set variable value, you should use one of the following functions, depending on the variable type: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> XPathVariable::Set(<span class="keywordtype">bool</span> Value);</div>
<div class="line"><span class="keywordtype">bool</span> XPathVariable::Set(<span class="keywordtype">double</span> Value);</div>
<div class="line"><span class="keywordtype">bool</span> XPathVariable::Set(<span class="keyword">const</span> char_t* Value);</div>
<div class="line"><span class="keywordtype">bool</span> XPathVariable::Set(<span class="keyword">const</span> XPathNodeSet&amp; Value);</div>
</div><!-- fragment --><p> These functions modify the variable value. Note that no type conversions are performed; if the type mismatch occurs, the functions return false; they also return false on allocation failure. The variable values are copied to the internal variable storage, so you can modify or destroy them after the functions return. <br />
 <br />
 This is an example of using variables in XPath queries: </p><div class="fragment"><div class="line"><span class="comment">// Select nodes via compiled query</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathVariableSet.html">Mezzanine::XML::XPathVariableSet</a> vars;</div>
<div class="line">vars.<a class="code" href="classMezzanine_1_1XML_1_1XPathVariableSet.html#a28e5de15a37877c8f416d08ba2ed6bf5">Add</a>(<span class="stringliteral">&quot;remote&quot;</span>, <a class="code" href="namespaceMezzanine_1_1XML.html#a9bd26a1f9b2d49df236a663038cd77eea6fef12c664c945f50d6d94d2e2bf3b65">Mezzanine::XML::XPathTypeBoole</a>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathQuery.html">Mezzanine::XML::XPathQuery</a> QueryRemoteTools(<span class="stringliteral">&quot;/Profile/Tools/Tool[@AllowRemote = string($remote)]&quot;</span>, &amp;vars);</div>
<div class="line"></div>
<div class="line">vars.<a class="code" href="classMezzanine_1_1XML_1_1XPathVariableSet.html#ad9cb2cee4519720351327716d4398f97">Set</a>(<span class="stringliteral">&quot;remote&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line">XPathNodeSet ToolsRemote = QueryRemoteTools.EvaluateNodeSet(doc);</div>
<div class="line"></div>
<div class="line">vars.<a class="code" href="classMezzanine_1_1XML_1_1XPathVariableSet.html#ad9cb2cee4519720351327716d4398f97">Set</a>(<span class="stringliteral">&quot;remote&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> ToolsLocal = QueryRemoteTools.EvaluateNodeSet(doc);</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Remote tool: &quot;</span>;</div>
<div class="line">ToolsRemote[2].GetNode().Print(std::cout);</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Local tool: &quot;</span>;</div>
<div class="line">ToolsLocal[0].GetNode().Print(std::cout);</div>
<div class="line"></div>
<div class="line"><span class="comment">// You can pass the context directly to FindNodes/FindNode</span></div>
<div class="line"><a class="code" href="classMezzanine_1_1XML_1_1XPathNodeSet.html">Mezzanine::XML::XPathNodeSet</a> ToolsLocalImm = doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">FindNodes</a>(<span class="stringliteral">&quot;/Profile/Tools/Tool[@AllowRemote = string($remote)]&quot;</span>, &amp;vars);</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Local tool imm: &quot;</span>;</div>
<div class="line">ToolsLocalImm[0].GetNode().Print(std::cout);</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLXPathError"></a>
Error Handling</h2>
<p>There are two different mechanisms for error handling in XPath implementation; the mechanism used depends on whether exception support is disabled (this is controlled with XML_NO_EXCEPTIONS define). <br />
 <br />
 By default, XPath functions throw Mezzanine::XML::XPathException object in case of errors; additionally, in the event any memory allocation fails, an std::bad_alloc exception is thrown. Also Mezzanine::XML::XPathException is thrown if the query is evaluated to a node set, but the return type is not node set. If the query constructor succeeds (i.e. no exception is thrown), the query object is valid. Otherwise you can get the error details via one of the following functions: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* Mezzanine::XML::XPathException::what() <span class="keyword">const</span> throw();</div>
<div class="line">const <a class="code" href="namespaceMezzanine.html">Mezzanine</a>::XML::XPathParseResult&amp; <a class="code" href="namespaceMezzanine.html">Mezzanine</a>::XML::XPathException::Result() const;</div>
</div><!-- fragment --><p> If exceptions are disabled, then in the event of parsing failure the query is initialized to invalid state; you can test if the query object is valid by using it in a boolean expression: if (query) { ... }. Additionally, you can get parsing result via the Result() accessor: </p><div class="fragment"><div class="line"><span class="keyword">const</span> XPathParseResult&amp; XPathQuery::Result() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Without exceptions, evaluating invalid query results in false, empty string, NaN or an empty node set, depending on the type; evaluating a query as a node set results in an empty node set if the return type is not node set. <br />
 <br />
 The information about parsing result is returned via <a class="el" href="structMezzanine_1_1XML_1_1XPathParseResult.html" title="XPath parsing result. ">Mezzanine::XML::XPathParseResult</a> object. It contains parsing status and the offset of last successfully parsed character from the beginning of the source stream. <br />
 <br />
 Parsing result is represented as the error message; it is either a null pointer, in case there is no error, or the error message in the form of ASCII zero-terminated string. <br />
 <br />
 The Description() member function can be used to get the error message; it never returns the null pointer, so you can safely use Description() even if query parsing succeeded. <br />
 <br />
 In addition to the error message, parsing result has an OffSet member, which contains the offset of last successfully parsed character. This offset is in units of Mezzanine::XML::char_t (bytes for character mode, wide characters for wide character mode). <br />
 <br />
 Parsing result object can be implicitly converted to bool like this: if (result) { ... } else { ... }. <br />
 <br />
 This is an example of XPath error handling: </p><div class="fragment"><div class="line"><span class="comment">// Exception is thrown for incorrect query syntax</span></div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">FindNodes</a>(<span class="stringliteral">&quot;//nodes[#true()]&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> Mezzanine::XML::XPathException&amp; e)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Select failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Exception is thrown for incorrect query semantics</span></div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">FindNodes</a>(<span class="stringliteral">&quot;(123)/next&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> Mezzanine::XML::XPathException&amp; e)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Select failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Exception is thrown for query with incorrect return type</span></div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    doc.<a class="code" href="classMezzanine_1_1XML_1_1Node.html#aa33661cf0b7ac69d67ed80ee74ff387c">FindNodes</a>(<span class="stringliteral">&quot;123&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> Mezzanine::XML::XPathException&amp; e)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Select failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="XMLXPathStandards"></a>
Conformance to W3C Specification</h2>
<p>Because of the differences in document object models, performance considerations and implementation complexity, pugixml does not provide a fully conformant XPath 1.0 implementation. This is the current list of incompatibilities:</p><ul>
<li>Consecutive text nodes sharing the same parent are not merged, i.e. in &lt;node&gt;text1 &lt;![CDATA[data]]&gt; text2 &lt;/node&gt; node should have one text node children, but instead has three.</li>
<li>Since the document type declaration is not used for parsing, id() function always returns an empty node set.</li>
<li>Namespace nodes are not supported (affects namespace:: axis).</li>
<li>Name tests are performed on QNames in XML document instead of expanded names; for &lt;foo xmlns:ns1='uri' xmlns:ns2='uri'&gt; &lt;ns1:child/&gt; &lt;ns2:child/&gt; &lt;/foo&gt;, query foo/ns1:* will return only the first child, not both of them. Compliant XPath implementations can return both nodes if the user provides appropriate namespace declarations.</li>
<li>String functions consider a character to be either a single char value or a single wchar_t value, depending on the library configuration; this means that some string functions are not fully Unicode-aware. This affects substring(), string-length() and translate() functions. </li>
</ul>
</div></div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 15 2016 01:51:48 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1</small></address>
</body>
</html>
