<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <title>BTS - Mezzanine::Threading::ReadWriteSpinLock Class Reference</title>
    <link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head>
<body onload=''>
<div id="top"><!-- do not remove this div! -->
    <div class="pagetitle">
        <a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>
        BlackTopp Studios<div class='smaller'> inc</div>
        <span id="projectnumber"></span>
    </div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMezzanine.html">Mezzanine</a></li><li class="navelem"><a class="el" href="namespaceMezzanine_1_1Threading.html">Threading</a></li><li class="navelem"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html">ReadWriteSpinLock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mezzanine::Threading::ReadWriteSpinLock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A mutex like construct that supports multiple readsingle writer semantics and never makes a system call and uses CPU instructions instead.  
 <a href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="readwritespinlock_8h_source.html">readwritespinlock.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9fb50dcfe3ff4b4616a4cdf3ca9f8520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fb50dcfe3ff4b4616a4cdf3ca9f8520"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a9fb50dcfe3ff4b4616a4cdf3ca9f8520">ReadWriteSpinLock</a> ()</td></tr>
<tr class="memdesc:a9fb50dcfe3ff4b4616a4cdf3ca9f8520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, creates an unlocked mutex. <br /></td></tr>
<tr class="separator:a9fb50dcfe3ff4b4616a4cdf3ca9f8520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622239a18c97cf35b15795843716b060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a622239a18c97cf35b15795843716b060"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a622239a18c97cf35b15795843716b060">~ReadWriteSpinLock</a> ()</td></tr>
<tr class="memdesc:a622239a18c97cf35b15795843716b060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a622239a18c97cf35b15795843716b060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1911d93b4a438e9a24828f8b43b4ce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1911d93b4a438e9a24828f8b43b4ce6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#ae1911d93b4a438e9a24828f8b43b4ce6">lock</a> ()</td></tr>
<tr class="memdesc:ae1911d93b4a438e9a24828f8b43b4ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply calls <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a288dcc5370bb4246c0ed5e2def13af24" title="Lock the ReadWriteSpinLock for Writing. ">LockForWrite()</a> for compatibility with <a class="el" href="classMezzanine_1_1Threading_1_1lock__guard.html" title="Lock guard class. ">lock_guard</a>. <br /></td></tr>
<tr class="separator:ae1911d93b4a438e9a24828f8b43b4ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca0328f0947ac27a030fb6cb9a2f0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a2ca0328f0947ac27a030fb6cb9a2f0e8">LockForRead</a> ()</td></tr>
<tr class="memdesc:a2ca0328f0947ac27a030fb6cb9a2f0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html" title="A mutex like construct that supports multiple readsingle writer semantics and never makes a system ca...">ReadWriteSpinLock</a> for Reading.  <a href="#a2ca0328f0947ac27a030fb6cb9a2f0e8">More...</a><br /></td></tr>
<tr class="separator:a2ca0328f0947ac27a030fb6cb9a2f0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288dcc5370bb4246c0ed5e2def13af24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a288dcc5370bb4246c0ed5e2def13af24">LockForWrite</a> ()</td></tr>
<tr class="memdesc:a288dcc5370bb4246c0ed5e2def13af24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html" title="A mutex like construct that supports multiple readsingle writer semantics and never makes a system ca...">ReadWriteSpinLock</a> for Writing.  <a href="#a288dcc5370bb4246c0ed5e2def13af24">More...</a><br /></td></tr>
<tr class="separator:a288dcc5370bb4246c0ed5e2def13af24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d9e5c16c663dabadfb94348b0b5ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a058d9e5c16c663dabadfb94348b0b5ac">TryLockForRead</a> ()</td></tr>
<tr class="memdesc:a058d9e5c16c663dabadfb94348b0b5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock this for reading.  <a href="#a058d9e5c16c663dabadfb94348b0b5ac">More...</a><br /></td></tr>
<tr class="separator:a058d9e5c16c663dabadfb94348b0b5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4416bb264eb1d1fe95248dcf80655ebe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a4416bb264eb1d1fe95248dcf80655ebe">TryLockForWrite</a> ()</td></tr>
<tr class="memdesc:a4416bb264eb1d1fe95248dcf80655ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock this for writing.  <a href="#a4416bb264eb1d1fe95248dcf80655ebe">More...</a><br /></td></tr>
<tr class="separator:a4416bb264eb1d1fe95248dcf80655ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd0b7ec1364091fbb2e1ac32ce0c5c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd0b7ec1364091fbb2e1ac32ce0c5c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a8cd0b7ec1364091fbb2e1ac32ce0c5c0">unlock</a> ()</td></tr>
<tr class="memdesc:a8cd0b7ec1364091fbb2e1ac32ce0c5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply calls <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#ae495786d55dbf28f4d6d9c63c2e5c42a" title="Unlock this for writing. ">UnlockWrite()</a> for compatibility with <a class="el" href="classMezzanine_1_1Threading_1_1lock__guard.html" title="Lock guard class. ">lock_guard</a>. <br /></td></tr>
<tr class="separator:a8cd0b7ec1364091fbb2e1ac32ce0c5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a76418a8ff039860d208520e8696d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a78a76418a8ff039860d208520e8696d1">UnlockRead</a> ()</td></tr>
<tr class="memdesc:a78a76418a8ff039860d208520e8696d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock this .  <a href="#a78a76418a8ff039860d208520e8696d1">More...</a><br /></td></tr>
<tr class="separator:a78a76418a8ff039860d208520e8696d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495786d55dbf28f4d6d9c63c2e5c42a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#ae495786d55dbf28f4d6d9c63c2e5c42a">UnlockWrite</a> ()</td></tr>
<tr class="memdesc:ae495786d55dbf28f4d6d9c63c2e5c42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock this for writing.  <a href="#ae495786d55dbf28f4d6d9c63c2e5c42a">More...</a><br /></td></tr>
<tr class="separator:ae495786d55dbf28f4d6d9c63c2e5c42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A mutex like construct that supports multiple readsingle writer semantics and never makes a system call and uses CPU instructions instead. </p>
<p>This should be used when delay is likely to be measured in CPUs cycles and almost certainly a short while. For pauses of unknown length use a <a class="el" href="classMezzanine_1_1Threading_1_1Mutex.html" title="A cross-platform abstraction of the OS&#39;s mutex. ">Mutex</a> so that the OS is informed it could schedule another thread. <br />
 <br />
Provided readers and writers call the correct functions this will only allow access to a single writer or a group of readers at one time </p>

<p>Definition at line <a class="el" href="readwritespinlock_8h_source.html#l00062">62</a> of file <a class="el" href="readwritespinlock_8h_source.html">readwritespinlock.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2ca0328f0947ac27a030fb6cb9a2f0e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::Threading::ReadWriteSpinLock::LockForRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html" title="A mutex like construct that supports multiple readsingle writer semantics and never makes a system ca...">ReadWriteSpinLock</a> for Reading. </p>
<p>The method will block the calling thread until a read lock be obtained. This remains locked until <code><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a78a76418a8ff039860d208520e8696d1" title="Unlock this . ">UnlockRead()</a></code> is called. <br />
 <br />
Multiple read locks can be obtained. If this is locked multiple this will keep count until <code><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#a78a76418a8ff039860d208520e8696d1" title="Unlock this . ">UnlockRead()</a></code> decrements that count. </p>

<p>Definition at line <a class="el" href="readwritespinlock_8cpp_source.html#l00064">64</a> of file <a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a288dcc5370bb4246c0ed5e2def13af24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::Threading::ReadWriteSpinLock::LockForWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html" title="A mutex like construct that supports multiple readsingle writer semantics and never makes a system ca...">ReadWriteSpinLock</a> for Writing. </p>
<p>The method will block the calling thread until a write lock be obtained. This remains locked until <code><a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html#ae495786d55dbf28f4d6d9c63c2e5c42a" title="Unlock this for writing. ">UnlockWrite()</a></code> is called. <br />
 <br />
Only a single write lock can exist and it can co-exist with no read locks. </p>

<p>Definition at line <a class="el" href="readwritespinlock_8cpp_source.html#l00095">95</a> of file <a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a058d9e5c16c663dabadfb94348b0b5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Mezzanine::Threading::ReadWriteSpinLock::TryLockForRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock this for reading. </p>
<p>The method will try to lock the <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html" title="A mutex like construct that supports multiple readsingle writer semantics and never makes a system ca...">ReadWriteSpinLock</a> for Reading. If it fails, the function will return immediately (non-blocking). </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was acquired, or <code>false</code> if the lock could not be acquired. </dd></dl>

<p>Definition at line <a class="el" href="readwritespinlock_8cpp_source.html#l00067">67</a> of file <a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4416bb264eb1d1fe95248dcf80655ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Mezzanine::Threading::ReadWriteSpinLock::TryLockForWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock this for writing. </p>
<p>The method will try to lock the <a class="el" href="classMezzanine_1_1Threading_1_1ReadWriteSpinLock.html" title="A mutex like construct that supports multiple readsingle writer semantics and never makes a system ca...">ReadWriteSpinLock</a> for writing. If it fails, the function will return immediately (non-blocking). </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was acquired, or <code>false</code> if the lock could not be acquired. </dd></dl>

<p>Definition at line <a class="el" href="readwritespinlock_8cpp_source.html#l00098">98</a> of file <a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78a76418a8ff039860d208520e8696d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::Threading::ReadWriteSpinLock::UnlockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock this . </p>
<p>Decrement the reader count and If zero any threads that are waiting for the LockWrite method on this mutex, one of them will be unblocked. If locked for write, this does nothing. </p>

<p>Definition at line <a class="el" href="readwritespinlock_8cpp_source.html#l00086">86</a> of file <a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae495786d55dbf28f4d6d9c63c2e5c42a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::Threading::ReadWriteSpinLock::UnlockWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock this for writing. </p>
<p>If any threads are waiting for the read or write lock on this, one of them willbe unblocked. If locked for read this doe nothing. </p>

<p>Definition at line <a class="el" href="readwritespinlock_8cpp_source.html#l00116">116</a> of file <a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sqeaky/Code/MezzanineFresh/Mezzanine/src/Threading/<a class="el" href="readwritespinlock_8h_source.html">readwritespinlock.h</a></li>
<li>/home/sqeaky/Code/MezzanineFresh/Mezzanine/src/Threading/<a class="el" href="readwritespinlock_8cpp_source.html">readwritespinlock.cpp</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>
    <address class="footer">
        <small>
            Generated on Mon Jan 25 2016 01:20:02 for BlackTopp Studios inc by
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
            </a>
            1.8.9.1
        </small>
    </address>
</body>
</html>
