<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>$title</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script> 
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>MezzanineEngine&#160;<span id="projectnumber"></span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="SerializationMain"></a>
SerializationMain</h1>
<p>Serialization is the process of converting a class instance into a serial sequence of bits. DeSerialization is taking those bits and reconstructing the original object without losing anything of value (in theory the only things not saved are cached values or values calulated as they are needed). These bits could be just about anything, because of its ubiquity we chose to serialize to xml (or something so similar as to be indistinguishable from standard xml). This allows a wide variety of tools to be used when working with and verifying these serialized classes. Additionally, transmitting and storing xml is easy to do, and can be done with a variety of other factors in mind. The xml text can be sent down any stream, put in any file, compressed, queried. You should see <a class="el" href="XMLManual.html">Mezzanine::xml Manual</a> for information about the xml system itself. <br/>
 <br/>
 Topics:</p>
<ul>
<li><a class="el" href="Serialization.html#serializationxml">Serialization and XML</a></li>
<li><a class="el" href="Serialization.html#serializationintegration">Integrate Serialization into Your Code</a><ul>
<li><a class="el" href="Serialization.html#serializationmaking">Make a Serializable or a DeSerializable</a></li>
<li><a class="el" href="Serialization.html#serializationserializers">Working with Serializers and Deserializers</a></li>
<li><a class="el" href="Serialization.html#serializationlegacy">Integrating with External XML Providers</a></li>
</ul>
</li>
<li><a class="el" href="Serialization.html#serializationoperators">Serialization Operators</a></li>
<li><a class="el" href="Serialization.html#serializationmisc">Other little Things</a> </li>
</ul>
<h2><a class="anchor" id="serializationxml"></a>
Serialization and XML</h2>
<p>The process of serializing doesn't just convert from class instance to text. Since our end goal is to convert live objects to <a class="el" href="namespaceMezzanine_1_1XML.html" title="All tools for working with XML are located in this namespace. ">XML</a> it makes sense to closely integrate the Mezzanine::xml portion of the engine. If you plan on writing serialization and deserialization code you should read the following parts of the <a class="el" href="XMLManual.html">Mezzanine::xml Manual</a> at a minimum:</p>
<ul>
<li><a class="el" href="XMLManual.html#XMLDOM">Document Object Model</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessingBasics">Basic traversal functions</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingNodeData">Setting Node Data</a></li>
<li><a class="el" href="XMLManual.html#XMLModifyingAttributeData">Setting Attribute Data</a></li>
</ul>
<p>The central object that will carry information during this process is the <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>. The <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> is an excellent tool for converting and storing data in a single unified heirarchy. <br/>
 <br/>
 C++ and most other object oriented languages heavily imply that class inheritance should be structured as hierarchies. Additionally Hierarchies are implied when complex class has other complex classes or datatypes as members. Both of these structures map cleanly onto the kind of hierarchies that a well formed xml documents provide. <br/>
 <br/>
 There are some relationships in video game objects that cross normal hierarchical boundaries. For example, A constraint references two actors, and defines a relationship between them. When serialized the constraint simply stores the name of the actor and looks it up in the actor manager during deserialization. This implies that the actors exist already, or that there is some mechanism to create the constraint and fill in the actor later. Several mechanisms were discussed to accomplish this, some include: two passes of processing where constraint would be done in the second pass, a work queue that would store objects that couldn't be deserialized yet, a prefetcher that would dig through the xml to find the required object. <br/>
 <br/>
 Those methods all likely could have been made to work. However, they are not optimal for a variety of reasons. All of them have a set of preconditions and require more computing resources and could potentially delay loading or transmission times. Some of them heavily imply that all of the items to deserialize must be stored in the same xml source. Some demand access to xml that may not have been transmitted yet. <br/>
 <br/>
 The simplest, most performant way to work around the issues that cross-hierarchical relationships presented was to ignore them. More specifically, throw an exception if an object reference during deserialization is not present. Then we ask that programmers who write code that must store, transmit and reconstruct class instances be aware of the following preconditions So can produce their own solutions:</p>
<ul>
<li>CollisionShapes must come before Actors and AreaEffects</li>
<li>WorldNodes must come before Actors, Light and ParticleEffects. (this is still work in progress).<ul>
<li>Currently WorldNodes try to find the objects that are attached to them, and the attached tries to find the world node. (if one does not exist, this silently fails)</li>
</ul>
</li>
<li>Actors must come before constraints.</li>
<li>Actors may have a WorldNode inside them, if this is the case, then the actor must come before Lights and ParticleEffects Attached to it.</li>
<li>Actors must be done before SoundSets</li>
<li>Sounds must be done before SoundSet (Still in progress)</li>
</ul>
<p>The easyiest way to meet these conditions and not consume an inordinate amount of computing resources, is to pay attention to the order that items are serialized in. If a program serializes the worldnodes, then the actors, then everything else it will have relatively little trouble making it work. </p>
<h2><a class="anchor" id="serializationintegration"></a>
Integrate Serialization into Your Code</h2>
<p>There several ways to interact with the current serialization system. One might have to create a class that can be serialized or deserialized. There may be situations where another system is emitting xml and it must be intergrated into an existing game. It may be desired to create a 'factory' that produces objects from and xml source or create a sink to put objects into so they can be serialized. Here we will discuss some of the ways that the serialization system can be extended and what kind of assumptions it makes, so that anyone can write software that interacts with it cleanly. </p>
<h3><a class="anchor" id="serializationmaking"></a>
Make a Serializable or a DeSerializable</h3>
<p>Creating a class that be serialized is easy. There is just one function that it must implement. If a class implements this, it is said to be Serializable: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SerializableClass::ProtoSerialize(XML::Node&amp;) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> The member ProtoSerialize(XML::Node&amp;) is expected to accept a <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a> and attach exactly one <a class="el" href="classMezzanine_1_1Node.html">Node</a> to it. This new Serialized node should contain all the data stored in the current state of the object being serialized. Storing data outside of this one node could cause undefined behavior. <br/>
 <br/>
 The exact layout of the data in the Serialized <a class="el" href="classMezzanine_1_1Node.html">Node</a> is not pre-determined. The creator of that function need only take into account any difficulties DeSerializing when creating this. Because of this concern it is advisable name the Serialized node something unique and appropriate and to include a 'Version' attribute on it. If the class changes, the DeSerialization function will only need to check the 'Version' attribute to know if and how it can handle it. <br/>
 <br/>
 Integrating with the DeSerialization code is pretty easy too. There are two functions you are expected to implement to create a DeSerializable: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeSerializableClass::ProtoDeSerialize(<span class="keyword">const</span> XML::Node&amp;);</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a> DeSerializableClass::SerializableName();</div>
</div><!-- fragment --><p> The SerializableName() is expected to simply return the name of the xml elements this class will DeSerialize. For example A <a class="el" href="classMezzanine_1_1Vector3.html" title="This is used to represent a point in space, or a vector through space. ">Mezzanine::Vector3</a> returns "Vector3", and a Mezzanine::ActorRigid return "ActorRigid". If a class is both DeSerializable and serializable it makes sense to call this function when assigning the name to the Serialized <a class="el" href="classMezzanine_1_1Node.html">Node</a> it creates. <br/>
 <br/>
 ProtoDeSerialize(const XML::Node&amp;), accepts a <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>. The <a class="el" href="classMezzanine_1_1Node.html">Node</a> passed to it would correspond to the Serialized <a class="el" href="classMezzanine_1_1Node.html">Node</a> created by the ProtoSerialize(XML::Node&amp;) function listed above. If xml is created by something then this is calling code is expecting this function to be the correct deserialization function. It is advisable but not required to verify the name of the xml node matches what is expected and that the 'Version' is something this code can handle. It is also advisable that every piece of data pulled out is verified the best it can be. If exceptions are thrown for every discrepency, then programmers using this will create xml and code that produce no discrepencies. <br/>
 <br/>
 The following template make use of only the 3 functions described above to Serialize or DeSerialize class instances: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; std::ostream&amp; <a class="code" href="namespaceMezzanine.html#a9015c5e668e14b857a27888c56934148" title="Convert any class that supports serialization or has a serializer to a string of chars in a stream...">Serialize</a>(std::ostream&amp; Stream, <span class="keyword">const</span> T&amp; Converted, <span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a>&amp; Indent = <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a>(<span class="stringliteral">&quot;&quot;</span>) );</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; std::istream&amp; <a class="code" href="namespaceMezzanine.html#ad8989ea81ccd1ad6d59a11921f0239a4" title="Deserialize the next xml tag in the stream into a specific in memory class instance. ">DeSerialize</a>(std::istream&amp; Stream, T&amp; Converted);</div>
</div><!-- fragment --><p> The functions make calls on the Mezzanine::xml system and expect a fairly basic set of conditions to be met before they are used. Serialize accepts an output stream and the class instance to be Serialized. It will create an <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">XML::Document</a> and populate it data from the class provided and then emit that into the stream. DeSerialize accepts an inputstream and the object to be populated. It expects the next xml element in the stream to be a serialized version of the passed object and will then overwrite as many of the values of the passed object as possible with the serialized values. For small items DeSerialize is fine, where possible it is better to have the <a class="el" href="classMezzanine_1_1XML_1_1Document.html" title="The root node of any xml hierarchy is a Document. ">XML::Document</a> open the file or stream itself as to prevent the second pass through to find exactly one xml element. <br/>
 <br/>
 </p>
<h3><a class="anchor" id="serializationserializers"></a>
Working with Serializers and Deserializers</h3>
<p>In some cases, there are some pieces of information that cannot be supplied or entered by the class itself. This data must be provided by another class or upon creation of the class. This other class can implement the <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a>, <a class="el" href="classMezzanine_1_1DeSerializer.html" title="A tool for deserializing classes with specific issues deserializing them. ">DeSerializer</a>, or both interfaces to make working with large amounts of serialization easier. <br/>
 <br/>
 For example actors can only accept a mesh upon construction. So overwriting an existing actor is impossible to do completely. It expected to be partially implemented, to the extent possible, in the class members. But if you have the need to create Actors on the fly from data stored in files it makes sense to have a dedicated class or interface than can create these. Here is what goes into a <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a>: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Serializable&gt; <span class="keyword">class </span>Serializer</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1Serializer.html#addec7bf46f6d1b149eaf3e449c5d8501" title="Get all of the data from the serializable class instance. ">Serializer::ProtoSerializeAll</a>(XML::Node&amp; CurrentRoot) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::ostream&amp; <a class="code" href="classMezzanine_1_1Serializer.html#aa178dfa519a2e73e84c0a2f35b2b8b5f" title="Output the complete serialized data to a stream. ">Serializer::SerializeAll</a>(std::ostream&amp; Stream) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1Serializer.html#ae20b1167a26fe0d913c9123788d30657" title="Get all the serialized data about one class instance in an XML::Node. ">Serializer::ProtoSerialize</a>(<span class="keyword">const</span> Serializable&amp; Target, XML::Node&amp; CurrentRoot) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::ostream&amp; <a class="code" href="classMezzanine_1_1Serializer.html#af71f7716c36ba0a583ab1e29e08cac6d" title="Output the specified member to a stream. ">Serializer::Serialize</a>(std::ostream&amp; Stream, <span class="keyword">const</span> Serializable&amp; Target)</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="classMezzanine_1_1Serializer.html#ae20b1167a26fe0d913c9123788d30657" title="Get all the serialized data about one class instance in an XML::Node. ">Serializer::ProtoSerialize()</a> when implement should take the required steps to attach a Serialized <a class="el" href="classMezzanine_1_1Node.html">Node</a> to the Passed <a class="el" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">XML::Node</a> that represent the Serialization target. It is expected to get the extra information that the target cannot provide from somewhere else. Ideally the the <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a> can be, or be associated with, a manager or container of some kind. There is not default implementation of this. <br/>
 <br/>
 <a class="el" href="classMezzanine_1_1Serializer.html#af71f7716c36ba0a583ab1e29e08cac6d" title="Output the specified member to a stream. ">Serializer::Serialize()</a> Goes one step further than <a class="el" href="classMezzanine_1_1Serializer.html#ae20b1167a26fe0d913c9123788d30657" title="Get all the serialized data about one class instance in an XML::Node. ">Serializer::ProtoSerialize()</a> and also sends it down a stream. The default implements use <a class="el" href="classMezzanine_1_1Serializer.html#ae20b1167a26fe0d913c9123788d30657" title="Get all the serialized data about one class instance in an XML::Node. ">Serializer::ProtoSerialize()</a>. <br/>
 <br/>
 <a class="el" href="classMezzanine_1_1Serializer.html#addec7bf46f6d1b149eaf3e449c5d8501" title="Get all of the data from the serializable class instance. ">Serializer::ProtoSerializeAll()</a> performs a similar role to <a class="el" href="classMezzanine_1_1Serializer.html#ae20b1167a26fe0d913c9123788d30657" title="Get all the serialized data about one class instance in an XML::Node. ">Serializer::ProtoSerialize()</a>, but again, it goes one step further. Rather than accept a single Target to serialize it is expected that the <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a> go to the source of the Targets and serialize all of them that are available. All of the target should be contained in one <a class="el" href="classMezzanine_1_1Node.html">Node</a> attached to the <a class="el" href="classMezzanine_1_1Node.html">Node</a> the function accepts. This is not implemented by default, the logic is too specific to the items to be serialized. <br/>
 <br/>
 <a class="el" href="classMezzanine_1_1Serializer.html#aa178dfa519a2e73e84c0a2f35b2b8b5f" title="Output the complete serialized data to a stream. ">Serializer::SerializeAll()</a> uses <a class="el" href="classMezzanine_1_1Serializer.html#addec7bf46f6d1b149eaf3e449c5d8501" title="Get all of the data from the serializable class instance. ">Serializer::ProtoSerializeAll()</a> to send all of the available Targets in Serialized down a stream. <br/>
 <br/>
 The logic behind a <a class="el" href="classMezzanine_1_1DeSerializer.html" title="A tool for deserializing classes with specific issues deserializing them. ">DeSerializer</a> is similar to a <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a>. The same types of methods, even similar implementations if the function is implemented. Like the ProtoDeSerialize() individual DeSerializables implement, the functions on a <a class="el" href="classMezzanine_1_1DeSerializer.html" title="A tool for deserializing classes with specific issues deserializing them. ">DeSerializer</a> will be passed the nodes that would correspond to the those created by their counterparts on the <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a>. Here is the contents of a Deserializer: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> DeSerializable&gt; <span class="keyword">class </span>DeSerializer</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzanine_1_1DeSerializer.html#a59b92952b1465392178d6db736118c26" title="Convert An XML Node into a complete series of live class instances. ">DeSerializer::ProtoDeSerializeAll</a>(<span class="keyword">const</span> XML::Node&amp; OneNode) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::istream&amp; <a class="code" href="classMezzanine_1_1DeSerializer.html#ab2765b0fe8f803344c6965df50333073" title="Get One node that has several of the appropriate kinds of nodes as children and deserialize all of th...">DeSerializer::DeSerializeAll</a>(std::istream&amp; Stream)</div>
<div class="line">    <span class="keyword">virtual</span> DeSerializable* <a class="code" href="classMezzanine_1_1DeSerializer.html#af1a7d10744ae974c985ad762e7dd55bd" title="Convert An XML Node into a complete live data structure. ">DeSerializer::ProtoDeSerialize</a>(<span class="keyword">const</span> XML::Node&amp; OneNode) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::istream&amp; <a class="code" href="classMezzanine_1_1DeSerializer.html#aaf31c38d936ec89323c3cb9196a5a97f" title="Get the serialized version of all the live data from the stream. ">DeSerializer::DeSerialize</a>(std::istream&amp; Stream)</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a> <a class="code" href="classMezzanine_1_1DeSerializer.html#a99e25b2dab4cde22af1c77fa31665bae" title="This will return the Name of the element that Contains multiple of the items to be DeSerialized...">ContainerName</a>() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The function ContainerName() should be used when creating and verifying the xml element that is parent to the items DeSerialized by ProtoDeSerializeAll(). The Default implmentation of DeSerializeAll() will use ContainerName to verify it has extracted the correct <a class="el" href="classMezzanine_1_1Node.html">Node</a>. <br/>
 <br/>
 There is no technical reason why a class cannot be both a serializer and a deserializer, or even multiple kinds of Serializers or DeSerializers. To keep things simple the Managers provided by the <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> engine will store a pointer to the appropriate <a class="el" href="classMezzanine_1_1Serializer.html" title="A tool for serializing classes with specific issues serializing. ">Serializer</a> when one is required. </p>
<h3><a class="anchor" id="serializationlegacy"></a>
Integrating with External XML Providers</h3>
<p>Sometimes yu will be forced to work with a system that produces xml that is not structured in a similar way to this system. Sometimes it may be too costly or not possible to modify the code to integrate it. For these the following function exists: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="namespaceMezzanine.html#a519df380398999cb532245118b9cb6a2" title="Used to interface with a previous version of the serialization code. ">SloppyProtoSerialize</a>(<span class="keyword">const</span> T&amp; Converted, XML::Node&amp; CurrentRoot)</div>
</div><!-- fragment --><p> This function will make a call on the the stream insertion operator of the class passed in. If one doesn't exist it is easy to add one in your code without chaning the original source. If one does exist than you should probably copy/paste the whole function and re-implement it calling the functions that emit the <a class="el" href="namespaceMezzanine_1_1XML.html" title="All tools for working with XML are located in this namespace. ">XML</a> string or stream. If you want to implement a stream insertion operator, the function prototype should be similar to the stream insertion operator in the <a class="el" href="Serialization.html#serializationoperators">Serialization Operators</a> section. </p>
<h2><a class="anchor" id="serializationoperators"></a>
Serialization Operators</h2>
<p>The stream insertion (&lt;&lt;) and stream extraction (&gt;&gt;) operators can be used for serializing and deserializing most items in the <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> engine.</p>
<p>Unfortunately due to conflict with the stream insertion operators provided with the iostreams library these couldn't be made into a template. That doesn't mean that they are difficult to implement. Here is a typical implemenation of stream insertion operators for <a class="el" href="namespaceMezzanine_1_1XML.html" title="All tools for working with XML are located in this namespace. ">XML</a> serialization: </p>
<div class="fragment"><div class="line">std::ostream&amp; <a class="code" href="namespaceMezzanine.html#a6312a3f64c76f41fcdb718df0e9797de" title="Send a HashedString32 down a stream serialized. ">operator &lt;&lt; </a>(std::ostream&amp; stream, <span class="keyword">const</span> Mezzanine::ActorRigid&amp; ActorToSerialize)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespaceMezzanine.html#a9015c5e668e14b857a27888c56934148" title="Convert any class that supports serialization or has a serializer to a string of chars in a stream...">Serialize</a>(stream, ActorToSerialize);</div>
<div class="line">    <span class="keywordflow">return</span> stream;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::istream&amp; <a class="code" href="namespaceMezzanine.html#a89add003f8cceba502530c272b6f3583" title="Used to de-serialize an Mezzanine::Vector3 from a stream. ">operator &gt;&gt; </a>(std::istream&amp; stream, Mezzanine::ActorRigid&amp; x)</div>
<div class="line">    { <span class="keywordflow">return</span> <a class="code" href="namespaceMezzanine.html#ad8989ea81ccd1ad6d59a11921f0239a4" title="Deserialize the next xml tag in the stream into a specific in memory class instance. ">DeSerialize</a>(stream, x); }</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMezzanine.html#a89add003f8cceba502530c272b6f3583" title="Used to de-serialize an Mezzanine::Vector3 from a stream. ">operator &gt;&gt; </a>(<span class="keyword">const</span> <a class="code" href="classMezzanine_1_1XML_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree. ">Mezzanine::XML::Node</a>&amp; OneNode, Mezzanine::ActorRigid&amp; x)</div>
<div class="line">    { x.ProtoDeSerialize(OneNode); }</div>
</div><!-- fragment --><p> You will want to implement these functions with the appropriate type. The type Mezzanine::ActorRigid is used purely as example Though this is actual working code and was in the engine at one point, the current code is more sophiscticated <br/>
 <br/>
 The function operator&lt;&lt; simply calls Serialize and returns the stream, so it has all the pre and cost conditions of the Serialize function listed in the <a class="el" href="Serialization.html#serializationmaking">Make a Serializable or a DeSerializable</a> section. <br/>
 <br/>
 The stream extraction operators are a little bit more interesting. The operator&gt;&gt;(istream,YourType), by virtue of calling Deserialize will wind up taking two passes over the <a class="el" href="namespaceMezzanine_1_1XML.html" title="All tools for working with XML are located in this namespace. ">XML</a>. One looking for the ending tag that matches the first (it gets all the children of that tag too) and one performing the actual parsing. The operator&gt;&gt;(istream,YourType) will work only with completely parsed objects in memory. With the combination of these two all the heavy lifting of parsing is done up front, and the rest of the deserialization is just a bunch of pointer and string manipulation. Another possibility with your stream extraction operator, if you new that it had exactly one parent xml node ,you create without that first pass for improved performance. </p>
<h2><a class="anchor" id="serializationmisc"></a>
Other little Things</h2>
<p>To simplify and standardize errors thrown, the following functions exist: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMezzanine.html#a62f1e144b90a2cba5476d60d3945dfb9" title="Simply does some string concatenation, then throws an Exception. ">SerializeError</a>(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a>&amp; FailedTo, <span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a>&amp; ClassName, <a class="code" href="namespaceMezzanine.html#a7d765759d1196aae20197055f00498f8" title="Generally acts a single bit, true or false. ">Boole</a> SOrD = <span class="keyword">true</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMezzanine.html#a1c602c7cdfd67247b48ba57898d37c71" title="Simply does some string concatenation, then throws an Exception. ">DeSerializeError</a>(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a>&amp; FailedTo, <span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A datatype used to a series of characters. ">String</a>&amp; ClassName, <a class="code" href="namespaceMezzanine.html#a7d765759d1196aae20197055f00498f8" title="Generally acts a single bit, true or false. ">Boole</a> SOrD = <span class="keyword">false</span>);</div>
</div><!-- fragment --><p> Both of these functions throw a <a class="el" href="classMezzanine_1_1Exception.html" title="This is the exception thrown by most Mezzanine system that can throw exceptions. ">Mezzanine::Exception</a> with the descriptive text of "Could not {FailedTo} during {ClassName} [De]Serialization." If SOrD (Serialize Or Deserialize) is true the "De" is not printed. </p>
</div></div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 19 2014 15:37:50 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4</small></address>
</body>
</html>
