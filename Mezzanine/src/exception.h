// Â© Copyright 2010 - 2016 BlackTopp Studios Inc.
/* This file is part of The Mezzanine Engine.

    The Mezzanine Engine is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Mezzanine Engine is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with The Mezzanine Engine.  If not, see <http://www.gnu.org/licenses/>.
*/
/* The original authors have included a copy of the license specified above in the
   'Docs' folder. See 'gpl.txt'
*/
/* We welcome the use of the Mezzanine engine to anyone, including companies who wish to
   Build professional software and charge for their product.

   However there are some practical restrictions, so if your project involves
   any of the following you should contact us and we will try to work something
   out:
    - DRM or Copy Protection of any kind(except Copyrights)
    - Software Patents You Do Not Wish to Freely License
    - Any Kind of Linking to Non-GPL licensed Works
    - Are Currently In Violation of Another Copyright Holder's GPL License
    - If You want to change our code and not add a few hundred MB of stuff to
        your distribution

   These and other limitations could cause serious legal problems if you ignore
   them, so it is best to simply contact us or the Free Software Foundation, if
   you have any questions.

   Joseph Toppi - toppij@gmail.com
   John Blackwood - makoenergy02@gmail.com
*/

// WARNING!
// This file is automatically generated. If you change it your changes wil not persist.

#ifndef _exception_h
#define _exception_h

#include "datatypes.h"

/// @file
/// @brief This implements the exception hiearchy for Mezzanine.
/// @warning This file is automatically generated. If you change it your changes wil not persist.


namespace Mezzanine
{

    ///////////////////////////////////////////////////////////////////////////////
    /// @brief This is the exception thrown by most Mezzanine systems that can throw exceptions.
    class MEZZ_LIB ExceptionBase : public std::exception
    {
        public:
            /// @enum ExceptionCodes
            /// @brief This enum provides mapping/naming for all the core Mezzanine.
            /// @details This system might superficially look convoluted. It is designed to make
            /// capturing as much detail about problems as they occur.
            ///
            /// The numbers listed here must be unique to each exception. If an error code does not
            /// identify the problem exactly it should be considered 'Unknown' for as much as it does
            /// specify. For example, if there is an error opening a file for reading and writing, and
            /// we don't know why it failed, using @ref IO_EXCEPTION would make sense
            enum ExceptionCodes
            {
                FIRST_EXCEPTION = 0x01F00F00, ///< To allow some inspection of the Exception system this can be use to identify the lower numbered Exception
                IO_EXCEPTION = 0x01F00F00, ///< Thrown when there was an issue with IO but very little was known about it.
                IO_FILE_EXCEPTION = 0x01F01F00, ///< Thrown when there is an unknown issue with a file
                IO_FILE_READ_EXCEPTION = 0x01F01F01, ///< Thrown when a file could not be read and permissions seem to not be an issue (Filesystem/hardware issue?
                IO_FILE_WRITE_EXCEPTION = 0x01F01F02, ///< Thrown when a file could not be written and perimssions seem not to be an issue
                IO_FILE_NOT_FOUND_EXCEPTION = 0x01F01F03, ///< Thrown when a file was expected to be there, but was not
                IO_FILE_PERMISSION_EXCEPTION = 0x01F01F04, ///< Thrown when permission was denied to a file
                IO_DIRECTORY_EXCEPTION = 0x01F02F00, ///< Thrown when there is an unknown issue with a file
                IO_DIRECTORY_READ_EXCEPTION = 0x01F02F01, ///< Thrown when a directory could be read and it wasn't a permission issue
                IO_DIRECTORY_WRITE_EXCEPTION = 0x01F02F02, ///< Thrown when a directory could be written to and it wasn't a permission issue
                IO_DIRECTORY_NOT_FOUND_EXCEPTION = 0x01F02F03, ///< Thrown when a directory was expected to be there, but was not
                IO_DIRECTORY_PERMISSION_EXCEPTION = 0x01F02F04, ///< Thrown when permission is denied to a directory
                IO_NETWORK_EXCEPTION = 0x01F03F00, ///< Thrown when something unknown causes network IO to fail
                IO_NETWORK_READ_EXCEPTION = 0x01F03F01, ///< Thrown when data could not be read from the network (downloads)
                IO_NETWORK_WRITE_EXCEPTION = 0x01F03F02, ///< Thrown when data could not be read from the network (iloads)
                IO_NETWORK_NOT_FOUND_EXCEPTION = 0x01F03F03, ///< Thrown when no network connection is available
                IO_NETWORK_URL_EXCEPTION = 0x01F03F04, ///< Thrown when an address is invalid or could not be found
                IO_NETWORK_PERMISSION_EXCEPTION = 0x01F03F05, ///< Thrown when permision was denied to a network interface or network resource
                IO_WRITE_EXCEPTION = 0x01F08F00, ///< Thrown when a write is happening but something has prevented the underlying code from knowing what was writing
                IO_READ_EXCEPTION = 0x01F09F00, ///< Thrown when a read is happening but something has prevented the underlying code from knowing what was reading
                II_EXCEPTION = 0x02F00F00, ///< Thrown when an unknown error with using an Identifier and it is invalid
                II_IDENTITY_INVALID_EXCEPTION = 0x02F01F00, ///< Thrown when the identity string wasn't valid at all
                II_IDENTITY_NOT_FOUND_EXCEPTION = 0x02F02F00, ///< Thrown when the requested identity could not be found
                II_DUPLICATE_IDENTITY_EXCEPTION = 0x02F03F00, ///< Thrown when duplicates of teh same identity string exist
                MM_EXCEPTION = 0x03F00F00, ///< Thrown when an unknown memory management exception occurs
                MM_OUT_OF_MEMORY_EXCEPTION = 0x03F01F00, ///< Thrown when A memory allocation was attempted and failed
                MM_OUT_OF_BOUNDS_EXCEPTION = 0x03F02F00, ///< Thrown when attempted to access something that really should note be accessed
                SYNTAX_ERROR_EXCEPTION = 0x04F00F00, ///< Thrown when some kind of syntax exception
                SYNTAX_ERROR_EXCEPTION_XML = 0x04F01F00, ///< Thrown when and XML document is being parsed but is invalid
                SYNTAX_ERROR_EXCEPTION_XPATH = 0x04F02F00, ///< Thrown when an XPath query is being parsed but is invalid
                SYNTAX_ERROR_EXCEPTION_LUA = 0x04F03F00, ///< Thrown when lua code in incorrect
                SCRIPT_EXCEPTION = 0x05F00F00, ///< Thrown when an unknown error happens with a script
                SCRIPT_EXCEPTION_LUA = 0x05F01F00, ///< Thrown when an unknown error happens in a Lua script
                SCRIPT_EXCEPTION_LUA_YIELD = 0x05F01F01, ///< Thrown when Lua returns a yield and it should not have
                SCRIPT_EXCEPTION_LUA_RUNTIME = 0x05F01F02, ///< Thrown when a Lua script has a runtime error
                SCRIPT_EXCEPTION_LUA_ERRERR = 0x05F01F03, ///< Thrown when Lua has an error handling an error
                PARAMETERS_EXCEPTION = 0x06F01F00, ///< Thrown when parameters are checked at runtime and found invalid
                PARAMETERS_CAST_EXCEPTION = 0x06F01F01, ///< Thrown when a pointer parameter is checked at runtime and cannot be cast as expected
                PARAMETERS_RANGE_EXCEPTION = 0x06F01F02, ///< Thrown when a passed parameter is checked at runtime and not in the expected range
                ARITHMETIC_EXCEPTION = 0x00F01F00, ///< Thrown when Math has failed
                INVALID_VERSION_EXCEPTION = 0x00F02F00, ///< Thrown when a version is accessed/parsed/required and it cannot work correctly or is missing
                INVALID_STATE_EXCEPTION = 0x00F03F00, ///< Thrown when the available information should have worked but failed for unknown reasons
                RENDERINGAPI_EXCEPTION = 0x00F04F00, ///< Thrown when the graphics card/DirectX/OpenGL fail
                RT_ASSERTION_EXCEPTION = 0x00F05F00, ///< Thrown when a rutime assertion could have been Thrown
                INTERNAL_EXCEPTION = 0x00F06F00, ///< Thrown when an unknown internal error occurred
                NOT_IMPLEMENTED_EXCEPTION = 0x00F07F00, ///< Thrown when we just have not coded a thing yet, but we knew what the API should look like
                INVALID_ASSIGNMENT = 0x00F08F00, ///< Thrown when a complex class is assigned to itself or other invalid assignments occur
                LAST_EXCEPTION = 0x01F00F00 ///< To allow some inspection of the Exception system this can be use to identify the highest numbered Exception

            };

        private:
            /// @internal
            /// @brief This stores the exception type as a Mezzanine::String.
            const Mezzanine::String ExceptionTypeName;
            /// @internal
            /// @brief When converting to Java types this is the kind of exception this becomes.
            const Mezzanine::String ExceptionJavaTypeName;
            /// @internal
            /// @brief This stores the Error Message
            const Mezzanine::String ErrorMessage;
            /// @internal
            /// @brief This stores the function name where the exception originated.
            const Mezzanine::String Function;
            /// @internal
            /// @brief This stores the file where the exception originated.
            const Mezzanine::String File;
            /// @internal
            /// @brief This stores the line number where the exception originated.
            const Mezzanine::Whole Line;
        public:
            /// @brief Simple Constructor.
            /// @param TypeName The name of the type of exception being thrown.
            /// @param JavaTypeName What Java exception Corresponds to this?
            /// @param Message A basic description of the error.
            /// @param SrcFunction The name of the function from which this originated.
            /// @param SrcFile The name of the file from which this originated.
            /// @param FileLine The line on the named file from which this originated.
            /// @details Don't call this, use @ref MEZZ_EXCEPTION to throw these, it is much simpler.
            /// This constructor might change with time to include more data.
            ExceptionBase(const Mezzanine::String& TypeName,
                          const Mezzanine::String& JavaTypeName,
                          const Mezzanine::String& Message,
                          const Mezzanine::String& SrcFunction,
                          const Mezzanine::String& SrcFile,
                          const Mezzanine::Whole& FileLine);
            /// @brief Class destructor.
            virtual ~ExceptionBase() throw();

           ///////////////////////////////////////////////////////////////////////////////
            // Error Information
            /// @brief Gets the exception code for this exception.
            /// @return Returns the exception code for this exception.
            virtual Mezzanine::Whole GetExceptionCode() const throw() = 0;

            /// @brief Gets the function of the exception.
            /// @return Returns a const Mezzanine::String reference
            const Mezzanine::String& GetFunction() const throw();
            /// @brief Gets the file of the exception.
            /// @return Returns the name of the file this exception is being thrown from.
            const Mezzanine::String& GetFile() const throw();
            /// @brief Gets the line number of the exception.
            /// @return Returns the line in the file this exception is being thrown from.
            const Mezzanine::Whole& GetLine() const throw();

            ///////////////////////////////////////////////////////////////////////////////
            // Class MetaData
            /// @brief Gets the name of the exception type.
            /// @return Returns the exception type as a Mezzanine::String.
            const Mezzanine::String& GetExceptionTypeName() const throw();
            /// @brief Gets the name of the exception type.
            /// @return Returns the exception type as a Mezzanine::String.
            const Mezzanine::String& GetExceptionJavaTypeName() const throw();

            ///////////////////////////////////////////////////////////////////////////////
            // Error Messages
            /// @brief Constructs the complete message from all the information provided about the exception.
            /// @return Returns a Mezzanine::String with the complete error.
            Mezzanine::String GetCompleteMessage() const throw();
            /// @brief Retrieves the error message.
            /// @return This returns a Mezzanine::String that is the stored error message.
            virtual const char* what() const throw();
    };//Exception

    ///////////////////////////////////////////////////////////////////////////////
    /// @internal
    /// @struct ExceptionFactory
    /// @brief Template class that serves as the base for exception factories.
    /// @details Additional exceptions and their factories have to specialize from this template
    /// changing the type value to the new exception type.This allows our exception macro to find the
    /// appropriate factory at compile when template are being resolved. So this system can be
    /// extended with additional exceptions wherever desired. Attempting to create an unknown exception
    /// simply won't compile because the base exception class being abstract.
    ///////////////////////////////////////////////////////////////////////////////
    template <Mezzanine::Whole N>
    struct ExceptionFactory
    {
        /// @brief This allows parameterized uses of this type when, so exception can be throw without directly using the type system
        typedef ExceptionBase Type;
    }; //ExceptionFactory


    ///////////////////////////////////////////////////////////////////////////////
    // Exception code class definitions.

    
///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when there was an issue with IO but very little was known about it.
/// @ingroup exception_heirarchy IOException
/// @details When catching this in java look for @a java.io.IOException
///////////////////
class MEZZ_LIB IOException : public ExceptionBase
{
    public:
        /// @brief Thrown when there was an issue with IO but very little was known about it.
        static const Whole ExceptionCode = ExceptionBase::IO_EXCEPTION;

        /// @brief IOException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        IOException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief IOException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        IOException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("IOException", "java/io/IOException", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~IOException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return IOException::ExceptionCode; }
//
}; // \ IOException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< IOException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef IOException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when there is an unknown issue with a file
/// @ingroup exception_heirarchy FileException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB FileException : public IOException
{
    public:
        /// @brief Thrown when there is an unknown issue with a file
        static const Whole ExceptionCode = IOException::IO_FILE_EXCEPTION;

        /// @brief FileException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : IOException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief FileException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  IOException("FileException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~FileException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return FileException::ExceptionCode; }
//
}; // \ FileException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< FileException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef FileException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a file could not be read and permissions seem to not be an issue (Filesystem/hardware issue?
/// @ingroup exception_heirarchy FileReadException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB FileReadException : public FileException
{
    public:
        /// @brief Thrown when a file could not be read and permissions seem to not be an issue (Filesystem/hardware issue?
        static const Whole ExceptionCode = FileException::IO_FILE_READ_EXCEPTION;

        /// @brief FileReadException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileReadException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : FileException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief FileReadException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileReadException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  FileException("FileReadException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~FileReadException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return FileReadException::ExceptionCode; }
//
}; // \ FileReadException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< FileReadException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef FileReadException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a file could not be written and perimssions seem not to be an issue
/// @ingroup exception_heirarchy FileWriteException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB FileWriteException : public FileException
{
    public:
        /// @brief Thrown when a file could not be written and perimssions seem not to be an issue
        static const Whole ExceptionCode = FileException::IO_FILE_WRITE_EXCEPTION;

        /// @brief FileWriteException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileWriteException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : FileException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief FileWriteException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileWriteException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  FileException("FileWriteException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~FileWriteException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return FileWriteException::ExceptionCode; }
//
}; // \ FileWriteException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< FileWriteException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef FileWriteException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a file was expected to be there, but was not
/// @ingroup exception_heirarchy FileNotFoundException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB FileNotFoundException : public FileException
{
    public:
        /// @brief Thrown when a file was expected to be there, but was not
        static const Whole ExceptionCode = FileException::IO_FILE_NOT_FOUND_EXCEPTION;

        /// @brief FileNotFoundException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileNotFoundException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : FileException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief FileNotFoundException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FileNotFoundException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  FileException("FileNotFoundException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~FileNotFoundException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return FileNotFoundException::ExceptionCode; }
//
}; // \ FileNotFoundException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< FileNotFoundException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef FileNotFoundException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when permission was denied to a file
/// @ingroup exception_heirarchy FilePermissionException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB FilePermissionException : public FileException
{
    public:
        /// @brief Thrown when permission was denied to a file
        static const Whole ExceptionCode = FileException::IO_FILE_PERMISSION_EXCEPTION;

        /// @brief FilePermissionException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FilePermissionException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : FileException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief FilePermissionException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        FilePermissionException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  FileException("FilePermissionException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~FilePermissionException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return FilePermissionException::ExceptionCode; }
//
}; // \ FilePermissionException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< FilePermissionException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef FilePermissionException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when there is an unknown issue with a file
/// @ingroup exception_heirarchy DirectoryException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB DirectoryException : public IOException
{
    public:
        /// @brief Thrown when there is an unknown issue with a file
        static const Whole ExceptionCode = IOException::IO_DIRECTORY_EXCEPTION;

        /// @brief DirectoryException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : IOException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief DirectoryException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  IOException("DirectoryException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~DirectoryException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return DirectoryException::ExceptionCode; }
//
}; // \ DirectoryException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< DirectoryException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef DirectoryException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a directory could be read and it wasn't a permission issue
/// @ingroup exception_heirarchy DirectoryReadException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB DirectoryReadException : public DirectoryException
{
    public:
        /// @brief Thrown when a directory could be read and it wasn't a permission issue
        static const Whole ExceptionCode = DirectoryException::IO_DIRECTORY_READ_EXCEPTION;

        /// @brief DirectoryReadException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryReadException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : DirectoryException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief DirectoryReadException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryReadException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  DirectoryException("DirectoryReadException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~DirectoryReadException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return DirectoryReadException::ExceptionCode; }
//
}; // \ DirectoryReadException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< DirectoryReadException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef DirectoryReadException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a directory could be written to and it wasn't a permission issue
/// @ingroup exception_heirarchy DirectoryWriteException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB DirectoryWriteException : public DirectoryException
{
    public:
        /// @brief Thrown when a directory could be written to and it wasn't a permission issue
        static const Whole ExceptionCode = DirectoryException::IO_DIRECTORY_WRITE_EXCEPTION;

        /// @brief DirectoryWriteException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryWriteException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : DirectoryException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief DirectoryWriteException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryWriteException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  DirectoryException("DirectoryWriteException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~DirectoryWriteException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return DirectoryWriteException::ExceptionCode; }
//
}; // \ DirectoryWriteException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< DirectoryWriteException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef DirectoryWriteException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a directory was expected to be there, but was not
/// @ingroup exception_heirarchy DirectoryNotFoundException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB DirectoryNotFoundException : public DirectoryException
{
    public:
        /// @brief Thrown when a directory was expected to be there, but was not
        static const Whole ExceptionCode = DirectoryException::IO_DIRECTORY_NOT_FOUND_EXCEPTION;

        /// @brief DirectoryNotFoundException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryNotFoundException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : DirectoryException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief DirectoryNotFoundException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryNotFoundException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  DirectoryException("DirectoryNotFoundException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~DirectoryNotFoundException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return DirectoryNotFoundException::ExceptionCode; }
//
}; // \ DirectoryNotFoundException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< DirectoryNotFoundException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef DirectoryNotFoundException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when permission is denied to a directory
/// @ingroup exception_heirarchy DirectoryPermissionException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB DirectoryPermissionException : public DirectoryException
{
    public:
        /// @brief Thrown when permission is denied to a directory
        static const Whole ExceptionCode = DirectoryException::IO_DIRECTORY_PERMISSION_EXCEPTION;

        /// @brief DirectoryPermissionException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryPermissionException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : DirectoryException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief DirectoryPermissionException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        DirectoryPermissionException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  DirectoryException("DirectoryPermissionException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~DirectoryPermissionException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return DirectoryPermissionException::ExceptionCode; }
//
}; // \ DirectoryPermissionException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< DirectoryPermissionException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef DirectoryPermissionException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when something unknown causes network IO to fail
/// @ingroup exception_heirarchy NetworkException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NetworkException : public IOException
{
    public:
        /// @brief Thrown when something unknown causes network IO to fail
        static const Whole ExceptionCode = IOException::IO_NETWORK_EXCEPTION;

        /// @brief NetworkException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : IOException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NetworkException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  IOException("NetworkException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NetworkException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NetworkException::ExceptionCode; }
//
}; // \ NetworkException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NetworkException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NetworkException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when data could not be read from the network (downloads)
/// @ingroup exception_heirarchy NetworkReadException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NetworkReadException : public NetworkException
{
    public:
        /// @brief Thrown when data could not be read from the network (downloads)
        static const Whole ExceptionCode = NetworkException::IO_NETWORK_READ_EXCEPTION;

        /// @brief NetworkReadException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkReadException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : NetworkException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NetworkReadException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkReadException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  NetworkException("NetworkReadException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NetworkReadException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NetworkReadException::ExceptionCode; }
//
}; // \ NetworkReadException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NetworkReadException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NetworkReadException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when data could not be read from the network (iloads)
/// @ingroup exception_heirarchy NetworkWriteException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NetworkWriteException : public NetworkException
{
    public:
        /// @brief Thrown when data could not be read from the network (iloads)
        static const Whole ExceptionCode = NetworkException::IO_NETWORK_WRITE_EXCEPTION;

        /// @brief NetworkWriteException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkWriteException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : NetworkException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NetworkWriteException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkWriteException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  NetworkException("NetworkWriteException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NetworkWriteException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NetworkWriteException::ExceptionCode; }
//
}; // \ NetworkWriteException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NetworkWriteException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NetworkWriteException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when no network connection is available
/// @ingroup exception_heirarchy NetworkNotFoundException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NetworkNotFoundException : public NetworkException
{
    public:
        /// @brief Thrown when no network connection is available
        static const Whole ExceptionCode = NetworkException::IO_NETWORK_NOT_FOUND_EXCEPTION;

        /// @brief NetworkNotFoundException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkNotFoundException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : NetworkException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NetworkNotFoundException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkNotFoundException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  NetworkException("NetworkNotFoundException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NetworkNotFoundException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NetworkNotFoundException::ExceptionCode; }
//
}; // \ NetworkNotFoundException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NetworkNotFoundException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NetworkNotFoundException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an address is invalid or could not be found
/// @ingroup exception_heirarchy NetworkURLException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NetworkURLException : public NetworkException
{
    public:
        /// @brief Thrown when an address is invalid or could not be found
        static const Whole ExceptionCode = NetworkException::IO_NETWORK_URL_EXCEPTION;

        /// @brief NetworkURLException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkURLException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : NetworkException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NetworkURLException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkURLException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  NetworkException("NetworkURLException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NetworkURLException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NetworkURLException::ExceptionCode; }
//
}; // \ NetworkURLException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NetworkURLException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NetworkURLException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when permision was denied to a network interface or network resource
/// @ingroup exception_heirarchy NetworkPermissionException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NetworkPermissionException : public NetworkException
{
    public:
        /// @brief Thrown when permision was denied to a network interface or network resource
        static const Whole ExceptionCode = NetworkException::IO_NETWORK_PERMISSION_EXCEPTION;

        /// @brief NetworkPermissionException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkPermissionException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : NetworkException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NetworkPermissionException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NetworkPermissionException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  NetworkException("NetworkPermissionException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NetworkPermissionException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NetworkPermissionException::ExceptionCode; }
//
}; // \ NetworkPermissionException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NetworkPermissionException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NetworkPermissionException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a write is happening but something has prevented the underlying code from knowing what was writing
/// @ingroup exception_heirarchy IOWriteException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB IOWriteException : public IOException
{
    public:
        /// @brief Thrown when a write is happening but something has prevented the underlying code from knowing what was writing
        static const Whole ExceptionCode = IOException::IO_WRITE_EXCEPTION;

        /// @brief IOWriteException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        IOWriteException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : IOException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief IOWriteException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        IOWriteException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  IOException("IOWriteException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~IOWriteException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return IOWriteException::ExceptionCode; }
//
}; // \ IOWriteException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< IOWriteException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef IOWriteException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a read is happening but something has prevented the underlying code from knowing what was reading
/// @ingroup exception_heirarchy IOReadException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB IOReadException : public IOException
{
    public:
        /// @brief Thrown when a read is happening but something has prevented the underlying code from knowing what was reading
        static const Whole ExceptionCode = IOException::IO_READ_EXCEPTION;

        /// @brief IOReadException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        IOReadException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : IOException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief IOReadException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        IOReadException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  IOException("IOReadException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~IOReadException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return IOReadException::ExceptionCode; }
//
}; // \ IOReadException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< IOReadException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef IOReadException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an unknown error with using an Identifier and it is invalid
/// @ingroup exception_heirarchy InstanceIdentityException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InstanceIdentityException : public ExceptionBase
{
    public:
        /// @brief Thrown when an unknown error with using an Identifier and it is invalid
        static const Whole ExceptionCode = ExceptionBase::II_EXCEPTION;

        /// @brief InstanceIdentityException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InstanceIdentityException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("InstanceIdentityException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InstanceIdentityException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InstanceIdentityException::ExceptionCode; }
//
}; // \ InstanceIdentityException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InstanceIdentityException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InstanceIdentityException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when the identity string wasn't valid at all
/// @ingroup exception_heirarchy InstanceIdentityInvalidException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InstanceIdentityInvalidException : public InstanceIdentityException
{
    public:
        /// @brief Thrown when the identity string wasn't valid at all
        static const Whole ExceptionCode = InstanceIdentityException::II_IDENTITY_INVALID_EXCEPTION;

        /// @brief InstanceIdentityInvalidException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityInvalidException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : InstanceIdentityException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InstanceIdentityInvalidException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityInvalidException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  InstanceIdentityException("InstanceIdentityInvalidException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InstanceIdentityInvalidException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InstanceIdentityInvalidException::ExceptionCode; }
//
}; // \ InstanceIdentityInvalidException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InstanceIdentityInvalidException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InstanceIdentityInvalidException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when the requested identity could not be found
/// @ingroup exception_heirarchy InstanceIdentityNotFoundException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InstanceIdentityNotFoundException : public InstanceIdentityException
{
    public:
        /// @brief Thrown when the requested identity could not be found
        static const Whole ExceptionCode = InstanceIdentityException::II_IDENTITY_NOT_FOUND_EXCEPTION;

        /// @brief InstanceIdentityNotFoundException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityNotFoundException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : InstanceIdentityException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InstanceIdentityNotFoundException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityNotFoundException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  InstanceIdentityException("InstanceIdentityNotFoundException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InstanceIdentityNotFoundException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InstanceIdentityNotFoundException::ExceptionCode; }
//
}; // \ InstanceIdentityNotFoundException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InstanceIdentityNotFoundException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InstanceIdentityNotFoundException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when duplicates of teh same identity string exist
/// @ingroup exception_heirarchy InstanceIdentityDuplicateException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InstanceIdentityDuplicateException : public InstanceIdentityException
{
    public:
        /// @brief Thrown when duplicates of teh same identity string exist
        static const Whole ExceptionCode = InstanceIdentityException::II_DUPLICATE_IDENTITY_EXCEPTION;

        /// @brief InstanceIdentityDuplicateException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityDuplicateException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : InstanceIdentityException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InstanceIdentityDuplicateException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InstanceIdentityDuplicateException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  InstanceIdentityException("InstanceIdentityDuplicateException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InstanceIdentityDuplicateException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InstanceIdentityDuplicateException::ExceptionCode; }
//
}; // \ InstanceIdentityDuplicateException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InstanceIdentityDuplicateException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InstanceIdentityDuplicateException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an unknown memory management exception occurs
/// @ingroup exception_heirarchy MemoryManagementException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB MemoryManagementException : public ExceptionBase
{
    public:
        /// @brief Thrown when an unknown memory management exception occurs
        static const Whole ExceptionCode = ExceptionBase::MM_EXCEPTION;

        /// @brief MemoryManagementException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        MemoryManagementException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief MemoryManagementException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        MemoryManagementException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("MemoryManagementException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~MemoryManagementException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return MemoryManagementException::ExceptionCode; }
//
}; // \ MemoryManagementException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< MemoryManagementException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef MemoryManagementException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when A memory allocation was attempted and failed
/// @ingroup exception_heirarchy OutOfMemoryException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB OutOfMemoryException : public MemoryManagementException
{
    public:
        /// @brief Thrown when A memory allocation was attempted and failed
        static const Whole ExceptionCode = MemoryManagementException::MM_OUT_OF_MEMORY_EXCEPTION;

        /// @brief OutOfMemoryException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        OutOfMemoryException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : MemoryManagementException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief OutOfMemoryException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        OutOfMemoryException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  MemoryManagementException("OutOfMemoryException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~OutOfMemoryException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return OutOfMemoryException::ExceptionCode; }
//
}; // \ OutOfMemoryException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< OutOfMemoryException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef OutOfMemoryException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when attempted to access something that really should note be accessed
/// @ingroup exception_heirarchy MemoryOutOfBoundsException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB MemoryOutOfBoundsException : public MemoryManagementException
{
    public:
        /// @brief Thrown when attempted to access something that really should note be accessed
        static const Whole ExceptionCode = MemoryManagementException::MM_OUT_OF_BOUNDS_EXCEPTION;

        /// @brief MemoryOutOfBoundsException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        MemoryOutOfBoundsException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : MemoryManagementException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief MemoryOutOfBoundsException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        MemoryOutOfBoundsException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  MemoryManagementException("MemoryOutOfBoundsException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~MemoryOutOfBoundsException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return MemoryOutOfBoundsException::ExceptionCode; }
//
}; // \ MemoryOutOfBoundsException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< MemoryOutOfBoundsException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef MemoryOutOfBoundsException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when some kind of syntax exception
/// @ingroup exception_heirarchy SyntaxErrorException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB SyntaxErrorException : public ExceptionBase
{
    public:
        /// @brief Thrown when some kind of syntax exception
        static const Whole ExceptionCode = ExceptionBase::SYNTAX_ERROR_EXCEPTION;

        /// @brief SyntaxErrorException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief SyntaxErrorException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("SyntaxErrorException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~SyntaxErrorException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return SyntaxErrorException::ExceptionCode; }
//
}; // \ SyntaxErrorException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< SyntaxErrorException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef SyntaxErrorException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when and XML document is being parsed but is invalid
/// @ingroup exception_heirarchy SyntaxErrorXMLException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB SyntaxErrorXMLException : public SyntaxErrorException
{
    public:
        /// @brief Thrown when and XML document is being parsed but is invalid
        static const Whole ExceptionCode = SyntaxErrorException::SYNTAX_ERROR_EXCEPTION_XML;

        /// @brief SyntaxErrorXMLException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorXMLException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : SyntaxErrorException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief SyntaxErrorXMLException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorXMLException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  SyntaxErrorException("SyntaxErrorXMLException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~SyntaxErrorXMLException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return SyntaxErrorXMLException::ExceptionCode; }
//
}; // \ SyntaxErrorXMLException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< SyntaxErrorXMLException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef SyntaxErrorXMLException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an XPath query is being parsed but is invalid
/// @ingroup exception_heirarchy SyntaxErrorXPathException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB SyntaxErrorXPathException : public SyntaxErrorException
{
    public:
        /// @brief Thrown when an XPath query is being parsed but is invalid
        static const Whole ExceptionCode = SyntaxErrorException::SYNTAX_ERROR_EXCEPTION_XPATH;

        /// @brief SyntaxErrorXPathException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorXPathException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : SyntaxErrorException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief SyntaxErrorXPathException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorXPathException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  SyntaxErrorException("SyntaxErrorXPathException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~SyntaxErrorXPathException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return SyntaxErrorXPathException::ExceptionCode; }
//
}; // \ SyntaxErrorXPathException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< SyntaxErrorXPathException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef SyntaxErrorXPathException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when lua code in incorrect
/// @ingroup exception_heirarchy SyntaxErrorLuaException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB SyntaxErrorLuaException : public SyntaxErrorException
{
    public:
        /// @brief Thrown when lua code in incorrect
        static const Whole ExceptionCode = SyntaxErrorException::SYNTAX_ERROR_EXCEPTION_LUA;

        /// @brief SyntaxErrorLuaException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorLuaException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : SyntaxErrorException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief SyntaxErrorLuaException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        SyntaxErrorLuaException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  SyntaxErrorException("SyntaxErrorLuaException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~SyntaxErrorLuaException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return SyntaxErrorLuaException::ExceptionCode; }
//
}; // \ SyntaxErrorLuaException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< SyntaxErrorLuaException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef SyntaxErrorLuaException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an unknown error happens with a script
/// @ingroup exception_heirarchy ScriptException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ScriptException : public ExceptionBase
{
    public:
        /// @brief Thrown when an unknown error happens with a script
        static const Whole ExceptionCode = ExceptionBase::SCRIPT_EXCEPTION;

        /// @brief ScriptException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ScriptException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("ScriptException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ScriptException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ScriptException::ExceptionCode; }
//
}; // \ ScriptException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ScriptException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ScriptException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an unknown error happens in a Lua script
/// @ingroup exception_heirarchy ScriptLuaException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ScriptLuaException : public ScriptException
{
    public:
        /// @brief Thrown when an unknown error happens in a Lua script
        static const Whole ExceptionCode = ScriptException::SCRIPT_EXCEPTION_LUA;

        /// @brief ScriptLuaException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ScriptException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ScriptLuaException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ScriptException("ScriptLuaException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ScriptLuaException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ScriptLuaException::ExceptionCode; }
//
}; // \ ScriptLuaException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ScriptLuaException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ScriptLuaException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when Lua returns a yield and it should not have
/// @ingroup exception_heirarchy ScriptLuaYieldException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ScriptLuaYieldException : public ScriptLuaException
{
    public:
        /// @brief Thrown when Lua returns a yield and it should not have
        static const Whole ExceptionCode = ScriptLuaException::SCRIPT_EXCEPTION_LUA_YIELD;

        /// @brief ScriptLuaYieldException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaYieldException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ScriptLuaException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ScriptLuaYieldException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaYieldException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ScriptLuaException("ScriptLuaYieldException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ScriptLuaYieldException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ScriptLuaYieldException::ExceptionCode; }
//
}; // \ ScriptLuaYieldException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ScriptLuaYieldException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ScriptLuaYieldException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a Lua script has a runtime error
/// @ingroup exception_heirarchy ScriptLuaRuntimeException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ScriptLuaRuntimeException : public ScriptLuaException
{
    public:
        /// @brief Thrown when a Lua script has a runtime error
        static const Whole ExceptionCode = ScriptLuaException::SCRIPT_EXCEPTION_LUA_RUNTIME;

        /// @brief ScriptLuaRuntimeException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaRuntimeException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ScriptLuaException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ScriptLuaRuntimeException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaRuntimeException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ScriptLuaException("ScriptLuaRuntimeException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ScriptLuaRuntimeException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ScriptLuaRuntimeException::ExceptionCode; }
//
}; // \ ScriptLuaRuntimeException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ScriptLuaRuntimeException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ScriptLuaRuntimeException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when Lua has an error handling an error
/// @ingroup exception_heirarchy ScriptLuaErrErrException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ScriptLuaErrErrException : public ScriptLuaException
{
    public:
        /// @brief Thrown when Lua has an error handling an error
        static const Whole ExceptionCode = ScriptLuaException::SCRIPT_EXCEPTION_LUA_ERRERR;

        /// @brief ScriptLuaErrErrException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaErrErrException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ScriptLuaException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ScriptLuaErrErrException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ScriptLuaErrErrException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ScriptLuaException("ScriptLuaErrErrException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ScriptLuaErrErrException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ScriptLuaErrErrException::ExceptionCode; }
//
}; // \ ScriptLuaErrErrException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ScriptLuaErrErrException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ScriptLuaErrErrException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when parameters are checked at runtime and found invalid
/// @ingroup exception_heirarchy ParametersException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ParametersException : public ExceptionBase
{
    public:
        /// @brief Thrown when parameters are checked at runtime and found invalid
        static const Whole ExceptionCode = ExceptionBase::PARAMETERS_EXCEPTION;

        /// @brief ParametersException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ParametersException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ParametersException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ParametersException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("ParametersException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ParametersException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ParametersException::ExceptionCode; }
//
}; // \ ParametersException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ParametersException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ParametersException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a pointer parameter is checked at runtime and cannot be cast as expected
/// @ingroup exception_heirarchy ParametersCastException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ParametersCastException : public ParametersException
{
    public:
        /// @brief Thrown when a pointer parameter is checked at runtime and cannot be cast as expected
        static const Whole ExceptionCode = ParametersException::PARAMETERS_CAST_EXCEPTION;

        /// @brief ParametersCastException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ParametersCastException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ParametersException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ParametersCastException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ParametersCastException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ParametersException("ParametersCastException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ParametersCastException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ParametersCastException::ExceptionCode; }
//
}; // \ ParametersCastException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ParametersCastException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ParametersCastException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a passed parameter is checked at runtime and not in the expected range
/// @ingroup exception_heirarchy ParametersRangeException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ParametersRangeException : public ParametersException
{
    public:
        /// @brief Thrown when a passed parameter is checked at runtime and not in the expected range
        static const Whole ExceptionCode = ParametersException::PARAMETERS_RANGE_EXCEPTION;

        /// @brief ParametersRangeException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ParametersRangeException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ParametersException(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ParametersRangeException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ParametersRangeException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ParametersException("ParametersRangeException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ParametersRangeException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ParametersRangeException::ExceptionCode; }
//
}; // \ ParametersRangeException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ParametersRangeException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ParametersRangeException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when Math has failed
/// @ingroup exception_heirarchy ArithmeticException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB ArithmeticException : public ExceptionBase
{
    public:
        /// @brief Thrown when Math has failed
        static const Whole ExceptionCode = ExceptionBase::ARITHMETIC_EXCEPTION;

        /// @brief ArithmeticException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ArithmeticException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief ArithmeticException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        ArithmeticException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("ArithmeticException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~ArithmeticException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return ArithmeticException::ExceptionCode; }
//
}; // \ ArithmeticException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< ArithmeticException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef ArithmeticException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a version is accessed/parsed/required and it cannot work correctly or is missing
/// @ingroup exception_heirarchy InvalidVersionException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InvalidVersionException : public ExceptionBase
{
    public:
        /// @brief Thrown when a version is accessed/parsed/required and it cannot work correctly or is missing
        static const Whole ExceptionCode = ExceptionBase::INVALID_VERSION_EXCEPTION;

        /// @brief InvalidVersionException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InvalidVersionException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InvalidVersionException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InvalidVersionException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("InvalidVersionException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InvalidVersionException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InvalidVersionException::ExceptionCode; }
//
}; // \ InvalidVersionException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InvalidVersionException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InvalidVersionException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when the available information should have worked but failed for unknown reasons
/// @ingroup exception_heirarchy InvalidStateException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InvalidStateException : public ExceptionBase
{
    public:
        /// @brief Thrown when the available information should have worked but failed for unknown reasons
        static const Whole ExceptionCode = ExceptionBase::INVALID_STATE_EXCEPTION;

        /// @brief InvalidStateException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InvalidStateException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InvalidStateException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InvalidStateException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("InvalidStateException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InvalidStateException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InvalidStateException::ExceptionCode; }
//
}; // \ InvalidStateException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InvalidStateException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InvalidStateException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when the graphics card/DirectX/OpenGL fail
/// @ingroup exception_heirarchy RenderingAPIException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB RenderingAPIException : public ExceptionBase
{
    public:
        /// @brief Thrown when the graphics card/DirectX/OpenGL fail
        static const Whole ExceptionCode = ExceptionBase::RENDERINGAPI_EXCEPTION;

        /// @brief RenderingAPIException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        RenderingAPIException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief RenderingAPIException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        RenderingAPIException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("RenderingAPIException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~RenderingAPIException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return RenderingAPIException::ExceptionCode; }
//
}; // \ RenderingAPIException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< RenderingAPIException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef RenderingAPIException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a rutime assertion could have been Thrown
/// @ingroup exception_heirarchy RuntimeAssertionException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB RuntimeAssertionException : public ExceptionBase
{
    public:
        /// @brief Thrown when a rutime assertion could have been Thrown
        static const Whole ExceptionCode = ExceptionBase::RT_ASSERTION_EXCEPTION;

        /// @brief RuntimeAssertionException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        RuntimeAssertionException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief RuntimeAssertionException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        RuntimeAssertionException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("RuntimeAssertionException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~RuntimeAssertionException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return RuntimeAssertionException::ExceptionCode; }
//
}; // \ RuntimeAssertionException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< RuntimeAssertionException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef RuntimeAssertionException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when an unknown internal error occurred
/// @ingroup exception_heirarchy InternalException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InternalException : public ExceptionBase
{
    public:
        /// @brief Thrown when an unknown internal error occurred
        static const Whole ExceptionCode = ExceptionBase::INTERNAL_EXCEPTION;

        /// @brief InternalException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InternalException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InternalException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InternalException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("InternalException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InternalException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InternalException::ExceptionCode; }
//
}; // \ InternalException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InternalException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InternalException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when we just have not coded a thing yet, but we knew what the API should look like
/// @ingroup exception_heirarchy NotImplementedException
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB NotImplementedException : public ExceptionBase
{
    public:
        /// @brief Thrown when we just have not coded a thing yet, but we knew what the API should look like
        static const Whole ExceptionCode = ExceptionBase::NOT_IMPLEMENTED_EXCEPTION;

        /// @brief NotImplementedException Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NotImplementedException(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief NotImplementedException constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        NotImplementedException(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("NotImplementedException", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~NotImplementedException() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return NotImplementedException::ExceptionCode; }
//
}; // \ NotImplementedException

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< NotImplementedException::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef NotImplementedException Type;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Thrown when a complex class is assigned to itself or other invalid assignments occur
/// @ingroup exception_heirarchy InvalidAssignment
/// @details When catching this in java look for @a java.lang.XXXXX
///////////////////
class MEZZ_LIB InvalidAssignment : public ExceptionBase
{
    public:
        /// @brief Thrown when a complex class is assigned to itself or other invalid assignments occur
        static const Whole ExceptionCode = ExceptionBase::INVALID_ASSIGNMENT;

        /// @brief InvalidAssignment Name overwriting constructor.
        /// @param TypeName The name of this class.
        /// @param JavaTypeName When passed to Java what does this convert to?
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InvalidAssignment(
                const String& TypeName,
                const String& JavaTypeName,
                const String& Message,
                const String& SrcFunction,
                const String& SrcFile,
                const Whole& FileLine)
            : ExceptionBase(TypeName, JavaTypeName, Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief InvalidAssignment constructor.
        /// @param Message A basic description of the error.
        /// @param SrcFunction The name of the function from which this originated.
        /// @param SrcFile The name of the file from which this originated.
        /// @param FileLine The line on the named file from which this originated.
        /// @warning This probably shouldn't be called directly. Use @ref MEZZ_EXCEPTION if possible.
        InvalidAssignment(   const String& Message,
                            const String& SrcFunction,
                            const String& SrcFile,
                            const Whole& FileLine)
            :  ExceptionBase("InvalidAssignment", "java/lang/XXXXX", Message, SrcFunction, SrcFile, FileLine)
            {}

        /// @brief Class destructor.
        virtual ~InvalidAssignment() throw() {}

        /// @copydoc ExceptionBase::GetExceptionCode()
        virtual Whole GetExceptionCode() const throw()
            { return InvalidAssignment::ExceptionCode; }
//
}; // \ InvalidAssignment

/// @internal
/// @copydoc ExceptionFactory
template<>
struct ExceptionFactory< InvalidAssignment::ExceptionCode>
{
    /// @internal
    /// @copydoc ExceptionFactory::Type
    typedef InvalidAssignment Type;
};



#ifndef MEZZ_EXCEPTION
/// @brief An easy way to throw exceptions with rich information.
/// @details An important part of troubleshooting errors from the users perspective is being able to
/// tie a specific 'fix' to a specific error message. An important part of that is catching the
/// right exceptions at the right time. It is also important to not allocate more memory or other
/// resources while creating an exception.
/// @n @n
/// This macro makes doing all of these easy. Every exception thrown by this macro with provide the
/// function name, the file name and the line in the file from which it was thrown. That provides
/// all the information the developer needs to identify the issue. This uses some specific template
/// machinery to generate specifically typed exceptions static instances at compile to insure the
/// behaviors a programmer needs. Since these are allocated (optimized out really) when the program
/// is first loaded so there will be no allocations when this is called, and the type is controlled
/// by the error number parameter.
/// @n @n
/// As long as the developer provides a unique string for each failure, then any messages
/// logged or presented to the user or log will uniquely identify that specific problem. This
/// allows the user to perform very specific web searches and potentially allows
/// troubleshooters/technicians to skip lengthy diagnostics steps.
/// @param num A specific code from the @ref ExceptionBase::ExceptionCodes enum will control the
/// type of exception produced.
/// @param desc A message/description to be passed through to the exceptions constructor.
#define MEZZ_EXCEPTION(num, desc) throw Mezzanine::ExceptionFactory<num>::Type(desc, __func__, __FILE__, __LINE__ );
#endif

} // \Mezzanine
#endif // \_GenException_h
