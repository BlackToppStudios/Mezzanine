<html>
<head>
<title>OGRE: Ogre::RenderQueue Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceOgre.html">Ogre</a>      </li>
      <li><a class="el" href="classOgre_1_1RenderQueue.html">Ogre::RenderQueue</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>Ogre::RenderQueue Class Reference<br/>
<small>
[<a class="el" href="group__RenderSystem.html">RenderSystem</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Ogre::RenderQueue" --><!-- doxytag: inherits="Ogre::AllocatedObject" -->
<p>Class to manage the scene object rendering queue.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ogre::RenderQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classOgre_1_1RenderQueue__inherit__graph.gif" border="0" usemap="#Ogre_1_1RenderQueue_inherit__map" alt="Inheritance graph"/></div>
<map name="Ogre_1_1RenderQueue_inherit__map" id="Ogre_1_1RenderQueue_inherit__map">
<area shape="rect" id="node2" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator..." alt="" coords="9,5,148,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classOgre_1_1RenderQueue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to listen in on items being added to the render queue.  <a href="classOgre_1_1RenderQueue_1_1RenderableListener.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structOgre_1_1map.html">map</a>&lt; <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>, <br class="typebreak"/>
<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> * &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4cf42f3f073ba37a87a555e37143ed1e">QueueGroupIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator over queue groups.  <a href="#a4cf42f3f073ba37a87a555e37143ed1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#add383352b6e187bfd9ee4f09753df493">ConstQueueGroupIterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a5454a3907c8ce62ab9454b7e4e6ef818">RenderQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a15db5053b0d5bbd21cf9e797ea06f0d9">~RenderQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a7351e9922649a71a54fb5b0ccfb525c4">clear</a> (bool destroyPassMaps=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empty the queue - should only be called by SceneManagers.  <a href="#a7351e9922649a71a54fb5b0ccfb525c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a6d85342418d78d733f887530e73da1c0">getQueueGroup</a> (<a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> qid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a render queue group.  <a href="#a6d85342418d78d733f887530e73da1c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aedb30e0dd6cd6db7f74650d311a68013">addRenderable</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend, <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> groupID, <a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a renderable object to the queue.  <a href="#aedb30e0dd6cd6db7f74650d311a68013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a8b67aff41b50d24cef0420871ce6f3af">addRenderable</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend, <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> groupId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a renderable object to the queue.  <a href="#a8b67aff41b50d24cef0420871ce6f3af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#acc8caa5feac9cee401f34f5aa1918d0d">addRenderable</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a renderable object to the queue.  <a href="#acc8caa5feac9cee401f34f5aa1918d0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#ab263254bd0c13a91c44d5fafd18c16c3">getDefaultQueueGroup</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on.  <a href="#ab263254bd0c13a91c44d5fafd18c16c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aeb5d94b3d357524a08affce11c383374">setDefaultRenderablePriority</a> (<a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use.  <a href="#aeb5d94b3d357524a08affce11c383374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a3903367113d6a51591ad16faeb17e8e0">getDefaultRenderablePriority</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use.  <a href="#a3903367113d6a51591ad16faeb17e8e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aee86531136c2069ab7ed03ec8802b624">setDefaultQueueGroup</a> (<a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> grp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on.  <a href="#aee86531136c2069ab7ed03ec8802b624"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1MapIterator.html">QueueGroupIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a591e66972499413f4f911ab3dfcf0412">_getQueueGroupIterator</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method, returns an iterator for the queue groups.  <a href="#a591e66972499413f4f911ab3dfcf0412"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1ConstMapIterator.html">ConstQueueGroupIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a70fdfde9ce4912ab70f28bd5cc02e198">_getQueueGroupIterator</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a12c00d063c95049da895c7bfc8923311">setSplitPassesByLightingType</a> (bool split)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal.  <a href="#a12c00d063c95049da895c7bfc8923311"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a77c88b94513eac36f4128567f90b7c37">getSplitPassesByLightingType</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal.  <a href="#a77c88b94513eac36f4128567f90b7c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4edec1309abf170a0dd09612911fc4bc">setSplitNoShadowPasses</a> (bool split)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used.  <a href="#a4edec1309abf170a0dd09612911fc4bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a09c7465cff6abb0c131efcc5d637a6d4">getSplitNoShadowPasses</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used.  <a href="#a09c7465cff6abb0c131efcc5d637a6d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aac9a571f752196f24799e5aebb6bd715">setShadowCastersCannotBeReceivers</a> (bool ind)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not objects which cast shadows should be treated as never receiving shadows.  <a href="#aac9a571f752196f24799e5aebb6bd715"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4b21bd8a507d984603dbb252e42c949d">getShadowCastersCannotBeReceivers</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether or not objects which cast shadows should be treated as never receiving shadows.  <a href="#a4b21bd8a507d984603dbb252e42c949d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a4830aa759ae0619a637dc979f8f0d581">setRenderableListener</a> (<a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a renderable listener on the queue.  <a href="#a4830aa759ae0619a637dc979f8f0d581"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a0833e163d52c2fffef84dfe81af1606a">getRenderableListener</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a55552364f1a8ecb2fb9a166ef92e070a">merge</a> (const <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge render queue.  <a href="#a55552364f1a8ecb2fb9a166ef92e070a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a5af90d52791616e975fc0da4dc1ec78e">processVisibleObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *mo, <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, bool onlyShadowCasters, <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *visibleBounds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility method to perform the standard actions associated with getting a visible object to add itself to the queue.  <a href="#a5af90d52791616e975fc0da4dc1ec78e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">operator new, with debug line info  <a href="#a421b197ca3a38da17e2eb1531a645fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ac4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#ab78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">placement operator new  <a href="#ab78a921e54419be677839cdf15d1f0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">array operator new, with debug line info  <a href="#a4be37baef81876985aa1071ad5acc6dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#afa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#acb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#a595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#aaf91a53059c0a0f61c07d3a0753a3bfe">mGroups</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a7166e043e0913cb1e08e4737befce3f6">mDefaultQueueGroup</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current default queue group.  <a href="#a7166e043e0913cb1e08e4737befce3f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#af1e1472401b4e1d24676e60d41b4705d">mDefaultRenderablePriority</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default priority.  <a href="#af1e1472401b4e1d24676e60d41b4705d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#af5adba44e7d9c936efcb35d389d5bb58">mSplitPassesByLightingType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#a66986fa9c851664d568e3dbb5a2d40cb">mSplitNoShadowPasses</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#abfb15a31918778ed0e0c74aacf3358f6">mShadowCastersCannotBeReceivers</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderQueue.html#add07814ff649c3a7a914fa3961a83a3d">mRenderableListener</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class to manage the scene object rendering queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Objects are grouped by material to minimise rendering state changes. The map from material to renderable object is wrapped in a class for ease of use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class now includes the concept of 'queue groups' which allows the application adding the renderable to specifically schedule it so that it is included in a discrete group. Good for separating renderables into the main scene, backgrounds and overlays, and also could be used in the future for more complex multipass routines like stenciling. </dd></dl>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00092">92</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="add383352b6e187bfd9ee4f09753df493"></a><!-- doxytag: member="Ogre::RenderQueue::ConstQueueGroupIterator" ref="add383352b6e187bfd9ee4f09753df493" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstMapIterator.html">ConstMapIterator</a>&lt;<a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a>&gt; <a class="el" href="classOgre_1_1ConstMapIterator.html">Ogre::RenderQueue::ConstQueueGroupIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00098">98</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf42f3f073ba37a87a555e37143ed1e"></a><!-- doxytag: member="Ogre::RenderQueue::QueueGroupIterator" ref="a4cf42f3f073ba37a87a555e37143ed1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::RenderQueue::QueueGroupIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator over queue groups. </p>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00097">97</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a72db2e13a4ff894459d361bee8e85fdf"></a><!-- doxytag: member="Ogre::RenderQueue::RenderQueueGroupMap" ref="a72db2e13a4ff894459d361bee8e85fdf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structOgre_1_1map.html">map</a>&lt; <a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>, <a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a>* &gt;::type <a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">Ogre::RenderQueue::RenderQueueGroupMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00095">95</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5454a3907c8ce62ab9454b7e4e6ef818"></a><!-- doxytag: member="Ogre::RenderQueue::RenderQueue" ref="a5454a3907c8ce62ab9454b7e4e6ef818" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::RenderQueue::RenderQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a15db5053b0d5bbd21cf9e797ea06f0d9"></a><!-- doxytag: member="Ogre::RenderQueue::~RenderQueue" ref="a15db5053b0d5bbd21cf9e797ea06f0d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::RenderQueue::~RenderQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a591e66972499413f4f911ab3dfcf0412"></a><!-- doxytag: member="Ogre::RenderQueue::_getQueueGroupIterator" ref="a591e66972499413f4f911ab3dfcf0412" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MapIterator.html">QueueGroupIterator</a> Ogre::RenderQueue::_getQueueGroupIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method, returns an iterator for the queue groups. </p>

</div>
</div>
<a class="anchor" id="a70fdfde9ce4912ab70f28bd5cc02e198"></a><!-- doxytag: member="Ogre::RenderQueue::_getQueueGroupIterator" ref="a70fdfde9ce4912ab70f28bd5cc02e198" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ConstMapIterator.html">ConstQueueGroupIterator</a> Ogre::RenderQueue::_getQueueGroupIterator </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aedb30e0dd6cd6db7f74650d311a68013"></a><!-- doxytag: member="Ogre::RenderQueue::addRenderable" ref="aedb30e0dd6cd6db7f74650d311a68013" args="(Renderable *pRend, uint8 groupID, ushort priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>groupID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a renderable object to the queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This methods adds a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. This is the advanced version of the call which allows the renderable to be added to any queue. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Called by implementation of <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRend</em>&nbsp;</td><td>Pointer to the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupID</em>&nbsp;</td><td>The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>Controls the priority of the renderable within the queue group. If this number is raised, the renderable will be rendered later in the group compared to it's peers. Don't use this unless you really need to, manually ordering renderables prevents OGRE from sorting them for best efficiency. However this could be useful for ordering 2D elements manually for example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc8caa5feac9cee401f34f5aa1918d0d"></a><!-- doxytag: member="Ogre::RenderQueue::addRenderable" ref="acc8caa5feac9cee401f34f5aa1918d0d" args="(Renderable *pRend)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>pRend</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a renderable object to the queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This methods adds a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. This is the simplified version of the call which does not require a queue or priority to be specified. The queue group is taken from the current default (see setDefaultQueueGroup). The queue priority is take from the current default (see setDefaultRenderablePriority). </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Called by implementation of <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRend</em>&nbsp;</td><td>Pointer to the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b67aff41b50d24cef0420871ce6f3af"></a><!-- doxytag: member="Ogre::RenderQueue::addRenderable" ref="a8b67aff41b50d24cef0420871ce6f3af" args="(Renderable *pRend, uint8 groupId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::addRenderable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>pRend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>groupId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a renderable object to the queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This methods adds a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to the queue, which will be rendered later by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. This is the simplified version of the call which does not require a priority to be specified. The queue priority is take from the current default (see setDefaultRenderablePriority). </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Called by implementation of <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRend</em>&nbsp;</td><td>Pointer to the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to be added to the queue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupID</em>&nbsp;</td><td>The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7351e9922649a71a54fb5b0ccfb525c4"></a><!-- doxytag: member="Ogre::RenderQueue::clear" ref="a7351e9922649a71a54fb5b0ccfb525c4" args="(bool destroyPassMaps=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::clear </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>destroyPassMaps</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empty the queue - should only be called by SceneManagers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>destroyPassMaps</em>&nbsp;</td><td>Set to true to destroy all pass maps so that the queue is completely clean (useful when switching scene managers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab263254bd0c13a91c44d5fafd18c16c3"></a><!-- doxytag: member="Ogre::RenderQueue::getDefaultQueueGroup" ref="ab263254bd0c13a91c44d5fafd18c16c3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::RenderQueue::getDefaultQueueGroup </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </p>

</div>
</div>
<a class="anchor" id="a3903367113d6a51591ad16faeb17e8e0"></a><!-- doxytag: member="Ogre::RenderQueue::getDefaultRenderablePriority" ref="a3903367113d6a51591ad16faeb17e8e0" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> Ogre::RenderQueue::getDefaultRenderablePriority </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </p>

</div>
</div>
<a class="anchor" id="a6d85342418d78d733f887530e73da1c0"></a><!-- doxytag: member="Ogre::RenderQueue::getQueueGroup" ref="a6d85342418d78d733f887530e73da1c0" args="(uint8 qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a>* Ogre::RenderQueue::getQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>qid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a render queue group. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>OGRE registers new queue groups as they are requested, therefore this method will always return a valid group. </dd></dl>

</div>
</div>
<a class="anchor" id="a0833e163d52c2fffef84dfe81af1606a"></a><!-- doxytag: member="Ogre::RenderQueue::getRenderableListener" ref="a0833e163d52c2fffef84dfe81af1606a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a>* Ogre::RenderQueue::getRenderableListener </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00284">284</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b21bd8a507d984603dbb252e42c949d"></a><!-- doxytag: member="Ogre::RenderQueue::getShadowCastersCannotBeReceivers" ref="a4b21bd8a507d984603dbb252e42c949d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::getShadowCastersCannotBeReceivers </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether or not objects which cast shadows should be treated as never receiving shadows. </p>

</div>
</div>
<a class="anchor" id="a09c7465cff6abb0c131efcc5d637a6d4"></a><!-- doxytag: member="Ogre::RenderQueue::getSplitNoShadowPasses" ref="a09c7465cff6abb0c131efcc5d637a6d4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::getSplitNoShadowPasses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used. </p>

</div>
</div>
<a class="anchor" id="a77c88b94513eac36f4128567f90b7c37"></a><!-- doxytag: member="Ogre::RenderQueue::getSplitPassesByLightingType" ref="a77c88b94513eac36f4128567f90b7c37" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderQueue::getSplitPassesByLightingType </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </p>

</div>
</div>
<a class="anchor" id="a55552364f1a8ecb2fb9a166ef92e070a"></a><!-- doxytag: member="Ogre::RenderQueue::merge" ref="a55552364f1a8ecb2fb9a166ef92e070a" args="(const RenderQueue *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge render queue. </p>

</div>
</div>
<a class="anchor" id="acb46d4b0a597156d9ba5abc39d127792"></a><!-- doxytag: member="Ogre::RenderQueue::operator delete" ref="acb46d4b0a597156d9ba5abc39d127792" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00107">107</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8357fe4fb4849772b94baa4bf47c7ded"></a><!-- doxytag: member="Ogre::RenderQueue::operator delete" ref="a8357fe4fb4849772b94baa4bf47c7ded" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00095">95</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c727e879a260c37b00ce5505fe8e144"></a><!-- doxytag: member="Ogre::RenderQueue::operator delete" ref="a1c727e879a260c37b00ce5505fe8e144" args="(void *ptr, void *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00101">101</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a595ea4c05da8aa987d3800e65d23355d"></a><!-- doxytag: member="Ogre::RenderQueue::operator delete[]" ref="a595ea4c05da8aa987d3800e65d23355d" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00118">118</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93e6a86dde5483c053ca0f2a85bbfd6c"></a><!-- doxytag: member="Ogre::RenderQueue::operator delete[]" ref="a93e6a86dde5483c053ca0f2a85bbfd6c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00112">112</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4bdf968b7b9af8a5239a27da73d5711"></a><!-- doxytag: member="Ogre::RenderQueue::operator new" ref="ac4bdf968b7b9af8a5239a27da73d5711" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00072">72</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421b197ca3a38da17e2eb1531a645fa2"></a><!-- doxytag: member="Ogre::RenderQueue::operator new" ref="a421b197ca3a38da17e2eb1531a645fa2" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00067">67</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab78a921e54419be677839cdf15d1f0b8"></a><!-- doxytag: member="Ogre::RenderQueue::operator new" ref="ab78a921e54419be677839cdf15d1f0b8" args="(size_t sz, void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>placement operator new </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00078">78</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4be37baef81876985aa1071ad5acc6dd"></a><!-- doxytag: member="Ogre::RenderQueue::operator new[]" ref="a4be37baef81876985aa1071ad5acc6dd" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>array operator new, with debug line info </p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00085">85</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa2943846ba6a2b5824a12857139cf5e"></a><!-- doxytag: member="Ogre::RenderQueue::operator new[]" ref="afa2943846ba6a2b5824a12857139cf5e" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h_source.html#l00090">90</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h_source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5af90d52791616e975fc0da4dc1ec78e"></a><!-- doxytag: member="Ogre::RenderQueue::processVisibleObject" ref="a5af90d52791616e975fc0da4dc1ec78e" args="(MovableObject *mo, Camera *cam, bool onlyShadowCasters, VisibleObjectsBoundsInfo *visibleBounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::processVisibleObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="paramname"> <em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyShadowCasters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>visibleBounds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility method to perform the standard actions associated with getting a visible object to add itself to the queue. </p>
<p>This is a replacement for <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementations of the associated tasks related to calling <a class="el" href="classOgre_1_1MovableObject.html#ac77b03ec95bbe3de7d9b9d7993dc785e" title="Internal method by which the movable object must add Renderable subclass instances to the rendering q...">MovableObject::_updateRenderQueue</a>. </p>

</div>
</div>
<a class="anchor" id="aee86531136c2069ab7ed03ec8802b624"></a><!-- doxytag: member="Ogre::RenderQueue::setDefaultQueueGroup" ref="aee86531136c2069ab7ed03ec8802b624" args="(uint8 grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setDefaultQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>grp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </p>
<p>See the enum RenderQueueGroupID for what kind of values can be used here. </p>

</div>
</div>
<a class="anchor" id="aeb5d94b3d357524a08affce11c383374"></a><!-- doxytag: member="Ogre::RenderQueue::setDefaultRenderablePriority" ref="aeb5d94b3d357524a08affce11c383374" args="(ushort priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setDefaultRenderablePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </p>

</div>
</div>
<a class="anchor" id="a4830aa759ae0619a637dc979f8f0d581"></a><!-- doxytag: member="Ogre::RenderQueue::setRenderableListener" ref="a4830aa759ae0619a637dc979f8f0d581" args="(RenderableListener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setRenderableListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a renderable listener on the queue. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>There can only be a single renderable listener on the queue, since that listener has complete control over the techniques in use. </dd></dl>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00281">281</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac9a571f752196f24799e5aebb6bd715"></a><!-- doxytag: member="Ogre::RenderQueue::setShadowCastersCannotBeReceivers" ref="aac9a571f752196f24799e5aebb6bd715" args="(bool ind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setShadowCastersCannotBeReceivers </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ind</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not objects which cast shadows should be treated as never receiving shadows. </p>

</div>
</div>
<a class="anchor" id="a4edec1309abf170a0dd09612911fc4bc"></a><!-- doxytag: member="Ogre::RenderQueue::setSplitNoShadowPasses" ref="a4edec1309abf170a0dd09612911fc4bc" args="(bool split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setSplitNoShadowPasses </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>split</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used. </p>

</div>
</div>
<a class="anchor" id="a12c00d063c95049da895c7bfc8923311"></a><!-- doxytag: member="Ogre::RenderQueue::setSplitPassesByLightingType" ref="a12c00d063c95049da895c7bfc8923311" args="(bool split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderQueue::setSplitPassesByLightingType </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>split</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7166e043e0913cb1e08e4737befce3f6"></a><!-- doxytag: member="Ogre::RenderQueue::mDefaultQueueGroup" ref="a7166e043e0913cb1e08e4737befce3f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> <a class="el" href="classOgre_1_1RenderQueue.html#a7166e043e0913cb1e08e4737befce3f6">Ogre::RenderQueue::mDefaultQueueGroup</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current default queue group. </p>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00135">135</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1e1472401b4e1d24676e60d41b4705d"></a><!-- doxytag: member="Ogre::RenderQueue::mDefaultRenderablePriority" ref="af1e1472401b4e1d24676e60d41b4705d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#af851e71354d841df7138f9877c6f5931">ushort</a> <a class="el" href="classOgre_1_1RenderQueue.html#af1e1472401b4e1d24676e60d41b4705d">Ogre::RenderQueue::mDefaultRenderablePriority</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default priority. </p>

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00137">137</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf91a53059c0a0f61c07d3a0753a3bfe"></a><!-- doxytag: member="Ogre::RenderQueue::mGroups" ref="aaf91a53059c0a0f61c07d3a0753a3bfe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue.html#a72db2e13a4ff894459d361bee8e85fdf">RenderQueueGroupMap</a> <a class="el" href="classOgre_1_1RenderQueue.html#aaf91a53059c0a0f61c07d3a0753a3bfe">Ogre::RenderQueue::mGroups</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00133">133</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="add07814ff649c3a7a914fa3961a83a3d"></a><!-- doxytag: member="Ogre::RenderQueue::mRenderableListener" ref="add07814ff649c3a7a914fa3961a83a3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">RenderableListener</a>* <a class="el" href="classOgre_1_1RenderQueue.html#add07814ff649c3a7a914fa3961a83a3d">Ogre::RenderQueue::mRenderableListener</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00143">143</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="abfb15a31918778ed0e0c74aacf3358f6"></a><!-- doxytag: member="Ogre::RenderQueue::mShadowCastersCannotBeReceivers" ref="abfb15a31918778ed0e0c74aacf3358f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderQueue.html#abfb15a31918778ed0e0c74aacf3358f6">Ogre::RenderQueue::mShadowCastersCannotBeReceivers</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00141">141</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a66986fa9c851664d568e3dbb5a2d40cb"></a><!-- doxytag: member="Ogre::RenderQueue::mSplitNoShadowPasses" ref="a66986fa9c851664d568e3dbb5a2d40cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderQueue.html#a66986fa9c851664d568e3dbb5a2d40cb">Ogre::RenderQueue::mSplitNoShadowPasses</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00140">140</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5adba44e7d9c936efcb35d389d5bb58"></a><!-- doxytag: member="Ogre::RenderQueue::mSplitPassesByLightingType" ref="af5adba44e7d9c936efcb35d389d5bb58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderQueue.html#af5adba44e7d9c936efcb35d389d5bb58">Ogre::RenderQueue::mSplitPassesByLightingType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="OgreRenderQueue_8h_source.html#l00139">139</a> of file <a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreRenderQueue_8h_source.html">OgreRenderQueue.h</a></li>
</ul>
</div>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Wed Nov 3 2010 19:24:59
</p>
</body>
</html>
